{
  "version": 3,
  "sources": ["../src/index.ts", "../src/Atom.ts", "../src/utils/Tappable.ts", "../src/utils/Emitter.ts", "../src/derivations/DerivationEmitter.ts", "../src/derivations/DerivationValuelessEmitter.ts", "../src/derivations/IDerivation.ts", "../src/derivations/flatMap.ts", "../src/derivations/map.ts", "../src/utils/Stack.ts", "../src/derivations/prism/discoveryMechanism.ts", "../src/derivations/AbstractDerivation.ts", "../src/derivations/DerivationFromSource.ts", "../src/pointer.ts", "../src/utils/updateDeep.ts", "../src/Box.ts", "../src/derivations/ConstantDerivation.ts", "../src/derivations/iterateAndCountTicks.ts", "../src/Ticker.ts", "../src/derivations/iterateOver.ts", "../src/derivations/prism/prism.ts", "../src/PointerProxy.ts"],
  "sourcesContent": ["export type {IdentityDerivationProvider} from './Atom'\nexport {default as Atom, val, valueDerivation} from './Atom'\nexport {default as Box} from './Box'\nexport type {IBox} from './Box'\nexport {default as AbstractDerivation} from './derivations/AbstractDerivation'\nexport {default as ConstantDerivation} from './derivations/ConstantDerivation'\nexport {default as DerivationFromSource} from './derivations/DerivationFromSource'\nexport {isDerivation} from './derivations/IDerivation'\nexport type {IDerivation} from './derivations/IDerivation'\nexport {default as iterateAndCountTicks} from './derivations/iterateAndCountTicks'\nexport {default as iterateOver} from './derivations/iterateOver'\nexport {default as prism} from './derivations/prism/prism'\nexport {default as pointer, getPointerParts, isPointer} from './pointer'\nexport type {Pointer, PointerType} from './pointer'\nexport {default as Ticker} from './Ticker'\nexport {default as PointerProxy} from './PointerProxy'\n", "import get from 'lodash-es/get'\nimport isPlainObject from 'lodash-es/isPlainObject'\nimport last from 'lodash-es/last'\nimport DerivationFromSource from './derivations/DerivationFromSource'\nimport type {IDerivation} from './derivations/IDerivation'\nimport {isDerivation} from './derivations/IDerivation'\nimport type {Pointer, PointerType} from './pointer'\nimport {isPointer} from './pointer'\nimport pointer, {getPointerMeta} from './pointer'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport type {PathBasedReducer} from './utils/PathBasedReducer'\nimport updateDeep from './utils/updateDeep'\n\ntype Listener = (newVal: unknown) => void\n\nenum ValueTypes {\n  Dict,\n  Array,\n  Other,\n}\n\nexport interface IdentityDerivationProvider {\n  readonly $$isIdentityDerivationProvider: true\n  getIdentityDerivation(path: Array<string | number>): IDerivation<unknown>\n}\n\nconst getTypeOfValue = (v: unknown): ValueTypes => {\n  if (Array.isArray(v)) return ValueTypes.Array\n  if (isPlainObject(v)) return ValueTypes.Dict\n  return ValueTypes.Other\n}\n\nconst getKeyOfValue = (\n  v: unknown,\n  key: string | number,\n  vType: ValueTypes = getTypeOfValue(v),\n): unknown => {\n  if (vType === ValueTypes.Dict && typeof key === 'string') {\n    return (v as $IntentionalAny)[key]\n  } else if (vType === ValueTypes.Array && isValidArrayIndex(key)) {\n    return (v as $IntentionalAny)[key]\n  } else {\n    return undefined\n  }\n}\n\nconst isValidArrayIndex = (key: string | number): boolean => {\n  const inNumber = typeof key === 'number' ? key : parseInt(key, 10)\n  return (\n    !isNaN(inNumber) &&\n    inNumber >= 0 &&\n    inNumber < Infinity &&\n    (inNumber | 0) === inNumber\n  )\n}\n\nclass Scope {\n  children: Map<string | number, Scope> = new Map()\n  identityChangeListeners: Set<Listener> = new Set()\n  constructor(\n    readonly _parent: undefined | Scope,\n    readonly _path: (string | number)[],\n  ) {}\n\n  addIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.add(cb)\n  }\n\n  removeIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.delete(cb)\n    this._checkForGC()\n  }\n\n  removeChild(key: string | number) {\n    this.children.delete(key)\n    this._checkForGC()\n  }\n\n  getChild(key: string | number) {\n    return this.children.get(key)\n  }\n\n  getOrCreateChild(key: string | number) {\n    let child = this.children.get(key)\n    if (!child) {\n      child = child = new Scope(this, this._path.concat([key]))\n      this.children.set(key, child)\n    }\n    return child\n  }\n\n  _checkForGC() {\n    if (this.identityChangeListeners.size > 0) return\n    if (this.children.size > 0) return\n\n    if (this._parent) {\n      this._parent.removeChild(last(this._path) as string | number)\n    }\n  }\n}\n\nexport default class Atom<State extends {}>\n  implements IdentityDerivationProvider\n{\n  private _currentState: State\n  readonly $$isIdentityDerivationProvider = true\n  private readonly _rootScope: Scope\n  readonly pointer: Pointer<State>\n\n  constructor(initialState: State) {\n    this._currentState = initialState\n    this._rootScope = new Scope(undefined, [])\n    this.pointer = pointer({root: this as $FixMe, path: []})\n  }\n\n  setState(newState: State) {\n    const oldState = this._currentState\n    this._currentState = newState\n\n    this._checkUpdates(this._rootScope, oldState, newState)\n  }\n\n  getState() {\n    return this._currentState\n  }\n\n  getIn(path: (string | number)[]): unknown {\n    return path.length === 0 ? this.getState() : get(this.getState(), path)\n  }\n\n  reduceState: PathBasedReducer<State, State> = (\n    path: $IntentionalAny[],\n    reducer: $IntentionalAny,\n  ) => {\n    const newState = updateDeep(this.getState(), path, reducer)\n    this.setState(newState)\n    return newState\n  }\n\n  setIn(path: $FixMe[], val: $FixMe) {\n    return this.reduceState(path, () => val)\n  }\n\n  private _checkUpdates(scope: Scope, oldState: unknown, newState: unknown) {\n    if (oldState === newState) return\n    scope.identityChangeListeners.forEach((cb) => cb(newState))\n\n    if (scope.children.size === 0) return\n\n    // @todo we can probably skip checking value types\n    const oldValueType = getTypeOfValue(oldState)\n    const newValueType = getTypeOfValue(newState)\n\n    if (oldValueType === ValueTypes.Other && oldValueType === newValueType)\n      return\n\n    scope.children.forEach((childScope, childKey) => {\n      const oldChildVal = getKeyOfValue(oldState, childKey, oldValueType)\n      const newChildVal = getKeyOfValue(newState, childKey, newValueType)\n      this._checkUpdates(childScope, oldChildVal, newChildVal)\n    })\n  }\n\n  private _getOrCreateScopeForPath(path: (string | number)[]): Scope {\n    let curScope = this._rootScope\n    for (const pathEl of path) {\n      curScope = curScope.getOrCreateChild(pathEl)\n    }\n    return curScope\n  }\n\n  private _onPathValueChange = (\n    path: (string | number)[],\n    cb: (v: unknown) => void,\n  ) => {\n    const scope = this._getOrCreateScopeForPath(path)\n    scope.identityChangeListeners.add(cb)\n    const untap = () => {\n      scope.identityChangeListeners.delete(cb)\n    }\n    return untap\n  }\n\n  getIdentityDerivation(path: Array<string | number>): IDerivation<unknown> {\n    return new DerivationFromSource<$IntentionalAny>(\n      (listener) => this._onPathValueChange(path, listener),\n      () => this.getIn(path),\n    )\n  }\n}\n\nconst identityDerivationWeakMap = new WeakMap<{}, IDerivation<unknown>>()\n\nexport const valueDerivation = <P extends PointerType<$IntentionalAny>>(\n  pointer: P,\n): IDerivation<P extends PointerType<infer T> ? T : void> => {\n  const meta = getPointerMeta(pointer)\n\n  let derivation = identityDerivationWeakMap.get(meta)\n  if (!derivation) {\n    const root = meta.root\n    if (!isIdentityChangeProvider(root)) {\n      throw new Error(\n        `Cannot run valueDerivation() on a pointer whose root is not an IdentityChangeProvider`,\n      )\n    }\n    const {path} = meta\n    derivation = root.getIdentityDerivation(path)\n    identityDerivationWeakMap.set(meta, derivation)\n  }\n  return derivation as $IntentionalAny\n}\n\nfunction isIdentityChangeProvider(\n  val: unknown,\n): val is IdentityDerivationProvider {\n  return (\n    typeof val === 'object' &&\n    val !== null &&\n    (val as $IntentionalAny)['$$isIdentityDerivationProvider'] === true\n  )\n}\n\nexport const val = <P>(\n  pointerOrDerivationOrPlainValue: P,\n): P extends PointerType<infer T>\n  ? T\n  : P extends IDerivation<infer T>\n  ? T\n  : P extends undefined | null\n  ? P\n  : unknown => {\n  if (isPointer(pointerOrDerivationOrPlainValue)) {\n    return valueDerivation(\n      pointerOrDerivationOrPlainValue,\n    ).getValue() as $IntentionalAny\n  } else if (isDerivation(pointerOrDerivationOrPlainValue)) {\n    return pointerOrDerivationOrPlainValue.getValue() as $IntentionalAny\n  } else {\n    return pointerOrDerivationOrPlainValue as $IntentionalAny\n  }\n}\n", "type Untap = () => void\ntype UntapFromSource = () => void\n\ninterface IProps<V> {\n  tapToSource: (cb: (payload: V) => void) => UntapFromSource\n}\n\ntype Listener<V> = ((v: V) => void) | (() => void)\n\nexport default class Tappable<V> {\n  private _props: IProps<V>\n  private _tappers: Map<number, {bivarianceHack(v: V): void}['bivarianceHack']>\n  private _untapFromSource: null | UntapFromSource\n  private _lastTapperId: number\n  private _untapFromSourceTimeout: null | NodeJS.Timer = null\n\n  constructor(props: IProps<V>) {\n    this._lastTapperId = 0\n    this._untapFromSource = null\n    this._props = props\n    this._tappers = new Map()\n  }\n\n  private _check() {\n    if (this._untapFromSource) {\n      if (this._tappers.size === 0) {\n        this._scheduleToUntapFromSource()\n        /*\n         * this._untapFromSource()\n         * this._untapFromSource = null\n         */\n      }\n    } else {\n      if (this._tappers.size !== 0) {\n        this._untapFromSource = this._props.tapToSource(this._cb)\n      }\n    }\n  }\n\n  private _scheduleToUntapFromSource() {\n    if (this._untapFromSourceTimeout !== null) return\n    this._untapFromSourceTimeout = setTimeout(() => {\n      this._untapFromSourceTimeout = null\n      if (this._tappers.size === 0) {\n        this._untapFromSource!()\n\n        this._untapFromSource = null\n      }\n    }, 0)\n  }\n\n  private _cb: any = (arg: any): void => {\n    this._tappers.forEach((cb) => {\n      cb(arg)\n    })\n  }\n\n  tap(cb: Listener<V>): Untap {\n    const tapperId = this._lastTapperId++\n    this._tappers.set(tapperId, cb)\n    this._check()\n    return () => {\n      this._removeTapperById(tapperId)\n    }\n  }\n\n  /*\n   * tapImmediate(cb: Listener<V>): Untap {\n   *   const ret = this.tap(cb)\n   *   return ret\n   * }\n   */\n\n  private _removeTapperById(id: number) {\n    this._tappers.delete(id)\n    this._check()\n  }\n\n  // /**\n  //  * @deprecated\n  //  */\n  // map<T>(transform: {bivarianceHack(v: V): T}['bivarianceHack']): Tappable<T> {\n  //   return new Tappable({\n  //     tapToSource: (cb: (v: T) => void) => {\n  //       return this.tap((v: $IntentionalAny) => {\n  //         return cb(transform(v))\n  //       })\n  //     },\n  //   })\n  // }\n}\n", "import Tappable from './Tappable'\n\ntype Tapper<V> = (v: V) => void\ntype Untap = () => void\n\nexport default class Emitter<V> {\n  private _tappers: Map<any, (v: V) => void>\n  private _lastTapperId: number\n  readonly tappable: Tappable<V>\n  private _onNumberOfTappersChangeListener: undefined | ((n: number) => void)\n\n  constructor() {\n    this._lastTapperId = 0\n    this._tappers = new Map()\n    this.tappable = new Tappable({\n      tapToSource: (cb: Tapper<V>) => {\n        return this._tap(cb)\n      },\n    })\n  }\n\n  _tap(cb: Tapper<V>): Untap {\n    const tapperId = this._lastTapperId++\n    this._tappers.set(tapperId, cb)\n    this._onNumberOfTappersChangeListener &&\n      this._onNumberOfTappersChangeListener(this._tappers.size)\n    return () => {\n      this._removeTapperById(tapperId)\n    }\n  }\n\n  _removeTapperById(id: number) {\n    const oldSize = this._tappers.size\n    this._tappers.delete(id)\n    const newSize = this._tappers.size\n    if (oldSize !== newSize) {\n      this._onNumberOfTappersChangeListener &&\n        this._onNumberOfTappersChangeListener(this._tappers.size)\n    }\n  }\n\n  emit(payload: V) {\n    this._tappers.forEach((cb) => {\n      cb(payload)\n    })\n  }\n\n  hasTappers() {\n    return this._tappers.size !== 0\n  }\n\n  onNumberOfTappersChange(cb: (n: number) => void) {\n    this._onNumberOfTappersChangeListener = cb\n  }\n}\n", "import type Ticker from '../Ticker'\nimport Emitter from '../utils/Emitter'\nimport type {default as Tappable} from '../utils/Tappable'\nimport type {IDerivation} from './IDerivation'\n\nexport default class DerivationEmitter<V> {\n  private _derivation: IDerivation<V>\n  private _ticker: Ticker\n  private _emitter: Emitter<V>\n  private _lastValue: undefined | V\n  private _lastValueRecorded: boolean\n  private _hadTappers: boolean\n\n  constructor(derivation: IDerivation<V>, ticker: Ticker) {\n    this._derivation = derivation\n    this._ticker = ticker\n    this._emitter = new Emitter()\n    this._emitter.onNumberOfTappersChange(() => {\n      this._reactToNumberOfTappersChange()\n    })\n    this._hadTappers = false\n    this._lastValueRecorded = false\n    this._lastValue = undefined\n    return this\n  }\n\n  private _possiblyMarkAsStale = () => {\n    this._ticker.onThisOrNextTick(this._refresh)\n  }\n\n  private _reactToNumberOfTappersChange() {\n    const hasTappers = this._emitter.hasTappers()\n    if (hasTappers !== this._hadTappers) {\n      this._hadTappers = hasTappers\n      if (hasTappers) {\n        this._derivation.addDependent(this._possiblyMarkAsStale)\n      } else {\n        this._derivation.removeDependent(this._possiblyMarkAsStale)\n      }\n    }\n  }\n\n  tappable(): Tappable<V> {\n    return this._emitter.tappable\n  }\n\n  private _refresh = () => {\n    const newValue = this._derivation.getValue()\n    if (newValue === this._lastValue && this._lastValueRecorded === true) return\n    this._lastValue = newValue\n    this._lastValueRecorded = true\n    this._emitter.emit(newValue)\n  }\n}\n", "import Emitter from '../utils/Emitter'\nimport type {default as Tappable} from '../utils/Tappable'\nimport type {IDerivation} from './IDerivation'\n\n/**\n * Just like DerivationEmitter, except it doesn't emit the value and doesn't need a ticker\n */\nexport default class DerivationValuelessEmitter<V> {\n  _derivation: IDerivation<V>\n  _emitter: Emitter<void>\n  _hadTappers: boolean\n\n  constructor(\n    derivation: IDerivation<V>,\n    readonly dontEmitValues: boolean = false,\n  ) {\n    this._derivation = derivation\n    this._emitter = new Emitter()\n    this._emitter.onNumberOfTappersChange(() => {\n      this._reactToNumberOfTappersChange()\n    })\n    this._hadTappers = false\n    return this\n  }\n\n  private _possiblyMarkAsStale = () => {\n    this._emitter.emit(undefined)\n  }\n\n  _reactToNumberOfTappersChange() {\n    const hasTappers = this._emitter.hasTappers()\n    if (hasTappers !== this._hadTappers) {\n      this._hadTappers = hasTappers\n      if (hasTappers) {\n        this._derivation.addDependent(this._possiblyMarkAsStale)\n      } else {\n        this._derivation.removeDependent(this._possiblyMarkAsStale)\n      }\n    }\n  }\n\n  tappable(): Tappable<void> {\n    return this._emitter.tappable\n  }\n}\n", "import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\nimport type Tappable from '../utils/Tappable'\n\ntype IDependent = (msgComingFrom: IDerivation<$IntentionalAny>) => void\nexport interface IDerivation<V> {\n  isDerivation: true\n  isHot: boolean\n  changes(ticker: Ticker): Tappable<V>\n\n  changesWithoutValues(): Tappable<void>\n  keepHot(): VoidFn\n  tapImmediate(ticker: Ticker, fn: (cb: V) => void): VoidFn\n  addDependent(d: IDependent): void\n  removeDependent(d: IDependent): void\n\n  getValue(): V\n\n  map<T>(fn: (v: V) => T): IDerivation<T>\n\n  flatMap<R>(\n    fn: (v: V) => R,\n  ): IDerivation<R extends IDerivation<infer T> ? T : R>\n}\n\nexport function isDerivation(d: any): d is IDerivation<unknown> {\n  return d && d.isDerivation && d.isDerivation === true\n}\n", "import type {$FixMe} from '../types'\nimport AbstractDerivation from './AbstractDerivation'\nimport type {IDerivation} from './IDerivation'\nimport {isDerivation} from './IDerivation'\n\nenum UPDATE_NEEDED_FROM {\n  none = 0,\n  dep = 1,\n  inner = 2,\n}\n\nconst makeFlatMapDerivationClass = () => {\n  class FlatMapDerivation<V, DepType> extends AbstractDerivation<V> {\n    private _innerDerivation: undefined | null | IDerivation<V>\n    private _staleDependency: UPDATE_NEEDED_FROM\n\n    static displayName = 'flatMap'\n\n    constructor(\n      readonly _depDerivation: IDerivation<DepType>,\n      readonly _fn: (v: DepType) => IDerivation<V> | V,\n    ) {\n      super()\n      this._innerDerivation = undefined\n      this._staleDependency = UPDATE_NEEDED_FROM.dep\n\n      this._addDependency(_depDerivation)\n\n      return this\n    }\n\n    _recalculateHot() {\n      const updateNeededFrom = this._staleDependency\n      this._staleDependency = UPDATE_NEEDED_FROM.none\n\n      if (updateNeededFrom === UPDATE_NEEDED_FROM.inner) {\n        // @ts-ignore\n        return this._innerDerivation.getValue()\n      }\n\n      const possibleInnerDerivation = this._fn(this._depDerivation.getValue())\n\n      if (isDerivation(possibleInnerDerivation)) {\n        this._innerDerivation = possibleInnerDerivation\n        this._addDependency(possibleInnerDerivation)\n        return possibleInnerDerivation.getValue()\n      } else {\n        return possibleInnerDerivation\n      }\n    }\n\n    protected _recalculateCold() {\n      const possibleInnerDerivation = this._fn(this._depDerivation.getValue())\n\n      if (isDerivation(possibleInnerDerivation)) {\n        return possibleInnerDerivation.getValue()\n      } else {\n        return possibleInnerDerivation\n      }\n    }\n\n    protected _recalculate() {\n      return this.isHot ? this._recalculateHot() : this._recalculateCold()\n    }\n\n    protected _reactToDependencyBecomingStale(\n      msgComingFrom: IDerivation<unknown>,\n    ) {\n      const updateNeededFrom =\n        msgComingFrom === this._depDerivation\n          ? UPDATE_NEEDED_FROM.dep\n          : UPDATE_NEEDED_FROM.inner\n\n      if (\n        updateNeededFrom === UPDATE_NEEDED_FROM.inner &&\n        msgComingFrom !== this._innerDerivation\n      ) {\n        throw Error(\n          `got a _reactToDependencyBecomingStale() from neither the dep nor the inner derivation`,\n        )\n      }\n\n      if (this._staleDependency === UPDATE_NEEDED_FROM.none) {\n        this._staleDependency = updateNeededFrom\n\n        if (updateNeededFrom === UPDATE_NEEDED_FROM.dep) {\n          this._removeInnerDerivation()\n        }\n      } else if (this._staleDependency === UPDATE_NEEDED_FROM.dep) {\n      } else {\n        if (updateNeededFrom === UPDATE_NEEDED_FROM.dep) {\n          this._staleDependency = UPDATE_NEEDED_FROM.dep\n          this._removeInnerDerivation()\n        }\n      }\n    }\n\n    private _removeInnerDerivation() {\n      if (this._innerDerivation) {\n        this._removeDependency(this._innerDerivation)\n        this._innerDerivation = undefined\n      }\n    }\n\n    protected _keepHot() {\n      this._staleDependency = UPDATE_NEEDED_FROM.dep\n      this.getValue()\n    }\n\n    protected _becomeCold() {\n      this._staleDependency = UPDATE_NEEDED_FROM.dep\n      this._removeInnerDerivation()\n    }\n  }\n  return FlatMapDerivation\n}\n\nlet cls: ReturnType<typeof makeFlatMapDerivationClass> | undefined = undefined\n\nexport default function flatMap<V, R>(\n  dep: IDerivation<V>,\n  fn: (v: V) => R,\n): IDerivation<R extends IDerivation<infer T> ? T : R> {\n  if (!cls) {\n    cls = makeFlatMapDerivationClass()\n  }\n  return new cls(dep, fn) as $FixMe\n}\n", "import AbstractDerivation from './AbstractDerivation'\nimport type {IDerivation} from './IDerivation'\n\n// Exporting from a function because of the circular dependency with AbstractDerivation\nconst makeMapDerivationClass = () =>\n  class MapDerivation<T, V> extends AbstractDerivation<V> {\n    constructor(\n      private readonly _dep: IDerivation<T>,\n      private readonly _fn: (t: T) => V,\n    ) {\n      super()\n      this._addDependency(_dep)\n    }\n\n    _recalculate() {\n      return this._fn(this._dep.getValue())\n    }\n\n    _reactToDependencyBecomingStale() {}\n  }\n\nlet cls: ReturnType<typeof makeMapDerivationClass> | undefined = undefined\n\nexport default function flatMap<V, R>(\n  dep: IDerivation<V>,\n  fn: (v: V) => R,\n): IDerivation<R> {\n  if (!cls) {\n    cls = makeMapDerivationClass()\n  }\n  return new cls(dep, fn)\n}\n", "interface Node<Data> {\n  next: undefined | Node<Data>\n  data: Data\n}\n\n/**\n * Just a simple LinkedList\n */\nexport default class Stack<Data> {\n  _head: undefined | Node<Data>\n\n  constructor() {\n    this._head = undefined\n  }\n\n  peek() {\n    return this._head && this._head.data\n  }\n\n  pop() {\n    const head = this._head\n    if (!head) {\n      return undefined\n    }\n    this._head = head.next\n    return head.data\n  }\n\n  push(data: Data) {\n    const node = {next: this._head, data}\n    this._head = node\n  }\n}\n", "import type {$IntentionalAny} from '../../types'\nimport Stack from '../../utils/Stack'\nimport type {IDerivation} from '../IDerivation'\n\nfunction createMechanism() {\n  const noop = () => {}\n\n  const stack = new Stack<Collector>()\n  const noopCollector: Collector = noop\n\n  type Collector = (d: IDerivation<$IntentionalAny>) => void\n\n  const pushCollector = (collector: Collector): void => {\n    stack.push(collector)\n  }\n\n  const popCollector = (collector: Collector): void => {\n    const existing = stack.peek()\n    if (existing !== collector) {\n      throw new Error(`Popped collector is not on top of the stack`)\n    }\n    stack.pop()\n  }\n\n  const startIgnoringDependencies = () => {\n    stack.push(noopCollector)\n  }\n\n  const stopIgnoringDependencies = () => {\n    if (stack.peek() !== noopCollector) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn('This should never happen')\n      }\n    } else {\n      stack.pop()\n    }\n  }\n\n  const reportResolutionStart = (d: IDerivation<$IntentionalAny>) => {\n    const possibleCollector = stack.peek()\n    if (possibleCollector) {\n      possibleCollector(d)\n    }\n\n    stack.push(noopCollector)\n  }\n\n  const reportResolutionEnd = (_d: IDerivation<$IntentionalAny>) => {\n    stack.pop()\n  }\n\n  return {\n    type: 'Dataverse_discoveryMechanism' as 'Dataverse_discoveryMechanism',\n    startIgnoringDependencies,\n    stopIgnoringDependencies,\n    reportResolutionStart,\n    reportResolutionEnd,\n    pushCollector,\n    popCollector,\n  }\n}\n\nfunction getSharedMechanism(): ReturnType<typeof createMechanism> {\n  const varName = '__dataverse_discoveryMechanism_sharedStack'\n  if (global) {\n    const existingMechanism: ReturnType<typeof createMechanism> | undefined =\n      // @ts-ignore ignore\n      global[varName]\n    if (\n      existingMechanism &&\n      typeof existingMechanism === 'object' &&\n      existingMechanism.type === 'Dataverse_discoveryMechanism'\n    ) {\n      return existingMechanism\n    } else {\n      const mechanism = createMechanism()\n      // @ts-ignore ignore\n      global[varName] = mechanism\n      return mechanism\n    }\n  } else {\n    return createMechanism()\n  }\n}\n\nexport const {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  reportResolutionEnd,\n  reportResolutionStart,\n  pushCollector,\n  popCollector,\n} = getSharedMechanism()\n", "import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\nimport type Tappable from '../utils/Tappable'\nimport DerivationEmitter from './DerivationEmitter'\nimport DerivationValuelessEmitter from './DerivationValuelessEmitter'\nimport flatMap from './flatMap'\nimport type {IDerivation} from './IDerivation'\nimport map from './map'\nimport {\n  reportResolutionEnd,\n  reportResolutionStart,\n} from './prism/discoveryMechanism'\n\ntype IDependent = (msgComingFrom: IDerivation<$IntentionalAny>) => void\nexport default abstract class AbstractDerivation<V> implements IDerivation<V> {\n  readonly isDerivation: true = true\n  private _didMarkDependentsAsStale: boolean = false\n  private _isHot: boolean = false\n\n  private _isFresh: boolean = false\n  protected _lastValue: undefined | V = undefined\n\n  protected _dependents: Set<IDependent> = new Set()\n  protected _dependencies: Set<IDerivation<$IntentionalAny>> = new Set()\n\n  protected abstract _recalculate(): V\n  protected abstract _reactToDependencyBecomingStale(\n    which: IDerivation<unknown>,\n  ): void\n\n  constructor() {}\n\n  get isHot(): boolean {\n    return this._isHot\n  }\n\n  protected _addDependency(d: IDerivation<$IntentionalAny>) {\n    if (this._dependencies.has(d)) return\n    this._dependencies.add(d)\n    if (this._isHot) d.addDependent(this._internal_markAsStale)\n  }\n\n  protected _removeDependency(d: IDerivation<$IntentionalAny>) {\n    if (!this._dependencies.has(d)) return\n    this._dependencies.delete(d)\n    if (this._isHot) d.removeDependent(this._internal_markAsStale)\n  }\n\n  changes(ticker: Ticker): Tappable<V> {\n    return new DerivationEmitter(this, ticker).tappable()\n  }\n\n  changesWithoutValues(): Tappable<void> {\n    return new DerivationValuelessEmitter(this).tappable()\n  }\n\n  keepHot() {\n    return this.changesWithoutValues().tap(() => {})\n  }\n\n  tapImmediate(ticker: Ticker, fn: (cb: V) => void): VoidFn {\n    const untap = this.changes(ticker).tap(fn)\n    fn(this.getValue())\n    return untap\n  }\n\n  addDependent(d: IDependent) {\n    const hadDepsBefore = this._dependents.size > 0\n    this._dependents.add(d)\n    const hasDepsNow = this._dependents.size > 0\n    if (hadDepsBefore !== hasDepsNow) {\n      this._reactToNumberOfDependentsChange()\n    }\n  }\n\n  /**\n   * @sealed\n   */\n  removeDependent(d: IDependent) {\n    const hadDepsBefore = this._dependents.size > 0\n    this._dependents.delete(d)\n    const hasDepsNow = this._dependents.size > 0\n    if (hadDepsBefore !== hasDepsNow) {\n      this._reactToNumberOfDependentsChange()\n    }\n  }\n\n  /**\n   * This is meant to be called by subclasses\n   *\n   * @sealed\n   */\n  protected _markAsStale(which: IDerivation<$IntentionalAny>) {\n    this._internal_markAsStale(which)\n  }\n\n  private _internal_markAsStale = (which: IDerivation<$IntentionalAny>) => {\n    this._reactToDependencyBecomingStale(which)\n\n    if (this._didMarkDependentsAsStale) return\n\n    this._didMarkDependentsAsStale = true\n    this._isFresh = false\n\n    this._dependents.forEach((dependent) => {\n      dependent(this)\n    })\n  }\n\n  getValue(): V {\n    reportResolutionStart(this)\n\n    if (!this._isFresh) {\n      const newValue = this._recalculate()\n      this._lastValue = newValue\n      if (this._isHot) {\n        this._isFresh = true\n        this._didMarkDependentsAsStale = false\n      }\n    }\n\n    reportResolutionEnd(this)\n    return this._lastValue!\n  }\n\n  private _reactToNumberOfDependentsChange() {\n    const shouldBecomeHot = this._dependents.size > 0\n\n    if (shouldBecomeHot === this._isHot) return\n\n    this._isHot = shouldBecomeHot\n    this._didMarkDependentsAsStale = false\n    this._isFresh = false\n    if (shouldBecomeHot) {\n      this._dependencies.forEach((d) => {\n        d.addDependent(this._internal_markAsStale)\n      })\n      this._keepHot()\n    } else {\n      this._dependencies.forEach((d) => {\n        d.removeDependent(this._internal_markAsStale)\n      })\n      this._becomeCold()\n    }\n  }\n\n  protected _keepHot() {}\n\n  protected _becomeCold() {}\n\n  map<T>(fn: (v: V) => T): IDerivation<T> {\n    return map(this, fn)\n  }\n\n  flatMap<R>(\n    fn: (v: V) => R,\n  ): IDerivation<R extends IDerivation<infer T> ? T : R> {\n    return flatMap(this, fn)\n  }\n}\n", "import type {VoidFn} from '../types'\nimport AbstractDerivation from './AbstractDerivation'\n\nconst noop = () => {}\n\nexport default class DerivationFromSource<V> extends AbstractDerivation<V> {\n  private _untapFromChanges: () => void\n  private _cachedValue: undefined | V\n  private _hasCachedValue: boolean\n\n  constructor(\n    private readonly _tapToSource: (listener: (newValue: V) => void) => VoidFn,\n    private readonly _getValueFromSource: () => V,\n  ) {\n    super()\n    this._untapFromChanges = noop\n    this._cachedValue = undefined\n    this._hasCachedValue = false\n  }\n\n  _recalculate() {\n    if (this.isHot) {\n      if (!this._hasCachedValue) {\n        this._cachedValue = this._getValueFromSource()\n        this._hasCachedValue = true\n      }\n      return this._cachedValue as V\n    } else {\n      return this._getValueFromSource()\n    }\n  }\n\n  _keepHot() {\n    this._hasCachedValue = false\n    this._cachedValue = undefined\n\n    this._untapFromChanges = this._tapToSource((newValue) => {\n      this._hasCachedValue = true\n      this._cachedValue = newValue\n      this._markAsStale(this)\n    })\n  }\n\n  _becomeCold() {\n    this._untapFromChanges()\n    this._untapFromChanges = noop\n\n    this._hasCachedValue = false\n    this._cachedValue = undefined\n  }\n\n  _reactToDependencyBecomingStale() {}\n}\n", "import type {$IntentionalAny} from './types'\n\ntype PathToProp = Array<string | number>\n\ntype PointerMeta = {\n  root: {}\n  path: (string | number)[]\n}\n\nexport type UnindexableTypesForPointer =\n  | number\n  | string\n  | boolean\n  | null\n  | void\n  | undefined\n  | Function // eslint-disable-line @typescript-eslint/ban-types\n\nexport type UnindexablePointer = {\n  [K in $IntentionalAny]: Pointer<undefined>\n}\n\nconst pointerMetaWeakMap = new WeakMap<{}, PointerMeta>()\n\nexport type PointerType<O> = {\n  $$__pointer_type: O\n}\n\nexport type Pointer<O> = PointerType<O> &\n  (O extends UnindexableTypesForPointer\n    ? UnindexablePointer\n    : unknown extends O\n    ? UnindexablePointer\n    : O extends (infer T)[]\n    ? Pointer<T>[]\n    : O extends {}\n    ? {\n        [K in keyof O]-?: Pointer<O[K]>\n      } /*&\n        {[K in string | number]: Pointer<K extends keyof O ? O[K] : undefined>}*/\n    : UnindexablePointer)\n\nconst pointerMetaSymbol = Symbol('pointerMeta')\n\nconst cachedSubPointersWeakMap = new WeakMap<\n  {},\n  Record<string | number, Pointer<unknown>>\n>()\n\nconst handler = {\n  get(obj: {}, prop: string | typeof pointerMetaSymbol): $IntentionalAny {\n    if (prop === pointerMetaSymbol) return pointerMetaWeakMap.get(obj)!\n\n    let subs = cachedSubPointersWeakMap.get(obj)\n    if (!subs) {\n      subs = {}\n      cachedSubPointersWeakMap.set(obj, subs)\n    }\n\n    if (subs[prop]) return subs[prop]\n\n    const meta = pointerMetaWeakMap.get(obj)!\n\n    const subPointer = pointer({root: meta.root, path: [...meta.path, prop]})\n    subs[prop] = subPointer\n    return subPointer\n  },\n}\n\nexport const getPointerMeta = (\n  p: Pointer<$IntentionalAny> | Pointer<{}> | Pointer<unknown>,\n): PointerMeta => {\n  // @ts-ignore @todo\n  const meta: PointerMeta = p[\n    pointerMetaSymbol as unknown as $IntentionalAny\n  ] as $IntentionalAny\n  return meta\n}\n\nexport const getPointerParts = (\n  p: Pointer<$IntentionalAny> | Pointer<{}> | Pointer<unknown>,\n): {root: {}; path: PathToProp} => {\n  const {root, path} = getPointerMeta(p)\n  return {root, path}\n}\n\nfunction pointer<O>({\n  root,\n  path,\n}: {\n  root: {}\n  path: Array<string | number>\n}): Pointer<O>\nfunction pointer(args: {root: {}; path?: Array<string | number>}) {\n  const meta: PointerMeta = {\n    root: args.root as $IntentionalAny,\n    path: args.path ?? [],\n  }\n  const hiddenObj = {}\n  pointerMetaWeakMap.set(hiddenObj, meta)\n  return new Proxy(hiddenObj, handler) as Pointer<$IntentionalAny>\n}\n\nexport default pointer\n\nexport const isPointer = (p: $IntentionalAny): p is Pointer<unknown> => {\n  return p && !!getPointerMeta(p)\n}\n", "import type {$FixMe, $IntentionalAny} from '../types'\n\nexport default function updateDeep<S>(\n  state: S,\n  path: (string | number | undefined)[],\n  reducer: (...args: $IntentionalAny[]) => $IntentionalAny,\n): S {\n  if (path.length === 0) return reducer(state)\n  return hoop(state, path as $IntentionalAny, reducer)\n}\n\nconst hoop = (\n  s: $FixMe,\n  path: (string | number)[],\n  reducer: $FixMe,\n): $FixMe => {\n  if (path.length === 0) {\n    return reducer(s)\n  }\n  if (Array.isArray(s)) {\n    let [index, ...restOfPath] = path\n    index = parseInt(String(index), 10)\n    if (isNaN(index)) index = 0\n    const oldVal = s[index]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = [...s]\n    newS.splice(index, 1, newVal)\n    return newS\n  } else if (typeof s === 'object' && s !== null) {\n    const [key, ...restOfPath] = path\n    const oldVal = s[key]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = {...s, [key]: newVal}\n    return newS\n  } else {\n    const [key, ...restOfPath] = path\n\n    return {[key]: hoop(undefined, restOfPath, reducer)}\n  }\n}\n", "import DerivationFromSource from './derivations/DerivationFromSource'\nimport type {IDerivation} from './derivations/IDerivation'\nimport Emitter from './utils/Emitter'\nexport interface IBox<V> {\n  set(v: V): void\n  get(): V\n  derivation: IDerivation<V>\n}\n\nexport default class Box<V> implements IBox<V> {\n  private _publicDerivation: IDerivation<V>\n  private _emitter = new Emitter<V>()\n\n  constructor(protected _value: V) {\n    this._publicDerivation = new DerivationFromSource(\n      (listener) => this._emitter.tappable.tap(listener),\n      this.get.bind(this),\n    )\n  }\n\n  set(v: V) {\n    if (v === this._value) return\n    this._value = v\n    this._emitter.emit(v)\n  }\n\n  get() {\n    return this._value\n  }\n\n  get derivation() {\n    return this._publicDerivation\n  }\n}\n", "import AbstractDerivation from './AbstractDerivation'\n\nexport default class ConstantDerivation<V> extends AbstractDerivation<V> {\n  _v: V\n\n  constructor(v: V) {\n    super()\n    this._v = v\n    return this\n  }\n\n  _recalculate() {\n    return this._v\n  }\n\n  _reactToDependencyBecomingStale() {}\n}\n", "import {valueDerivation} from '../Atom'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport type {IDerivation} from './IDerivation'\nimport {isDerivation} from './IDerivation'\n\nexport default function* iterateAndCountTicks<V>(\n  pointerOrDerivation: IDerivation<V> | Pointer<V>,\n): Generator<{value: V; ticks: number}, void, void> {\n  let d\n  if (isPointer(pointerOrDerivation)) {\n    d = valueDerivation(pointerOrDerivation) as IDerivation<V>\n  } else if (isDerivation(pointerOrDerivation)) {\n    d = pointerOrDerivation\n  } else {\n    throw new Error(`Only pointers and derivations are supported`)\n  }\n\n  let ticksCountedSinceLastYield = 0\n  const untap = d.changesWithoutValues().tap(() => {\n    ticksCountedSinceLastYield++\n  })\n\n  try {\n    while (true) {\n      const ticks = ticksCountedSinceLastYield\n      ticksCountedSinceLastYield = 0\n      yield {value: d.getValue(), ticks}\n    }\n  } finally {\n    untap()\n  }\n}\n", "type ICallback = (t: number) => void\n\nexport default class Ticker {\n  private _scheduledForThisOrNextTick: Set<ICallback>\n  private _scheduledForNextTick: Set<ICallback>\n  private _timeAtCurrentTick: number\n  private _ticking: boolean = false\n\n  constructor() {\n    this._scheduledForThisOrNextTick = new Set()\n    this._scheduledForNextTick = new Set()\n    this._timeAtCurrentTick = 0\n  }\n\n  /**\n   * Registers for fn to be called either on this tick or the next tick.\n   *\n   * If registerSideEffect() is called while Ticker.tick() is running, the\n   * side effect _will_ be called within the running tick. If you don't want this\n   * behavior, you can use registerSideEffectForNextTick().\n   *\n   * Note that fn will be added to a Set(). Which means, if you call registerSideEffect(fn)\n   * with the same fn twice in a single tick, it'll only run once.\n   */\n  onThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.add(fn)\n  }\n\n  /**\n   * Registers a side effect to be called on the next tick.\n   *\n   * @see Ticker:onThisOrNextTick()\n   */\n  onNextTick(fn: ICallback) {\n    this._scheduledForNextTick.add(fn)\n  }\n\n  offThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.delete(fn)\n  }\n\n  offNextTick(fn: ICallback) {\n    this._scheduledForNextTick.delete(fn)\n  }\n\n  get time() {\n    if (this._ticking) {\n      return this._timeAtCurrentTick\n    } else return performance.now()\n  }\n\n  tick(t: number = performance.now()) {\n    this._ticking = true\n    this._timeAtCurrentTick = t\n    this._scheduledForNextTick.forEach((v) =>\n      this._scheduledForThisOrNextTick.add(v),\n    )\n    this._scheduledForNextTick.clear()\n    this._tick(0)\n    this._ticking = false\n  }\n\n  private _tick(iterationNumber: number): void {\n    const time = this.time\n\n    if (iterationNumber > 10) {\n      console.warn('_tick() recursing for 10 times')\n    }\n\n    if (iterationNumber > 100) {\n      throw new Error(`Maximum recursion limit for _tick()`)\n    }\n\n    const oldSet = this._scheduledForThisOrNextTick\n    this._scheduledForThisOrNextTick = new Set()\n    oldSet.forEach((fn) => {\n      fn(time)\n    })\n\n    if (this._scheduledForThisOrNextTick.size > 0) {\n      return this._tick(iterationNumber + 1)\n    }\n  }\n}\n", "import {valueDerivation} from '../Atom'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport Ticker from '../Ticker'\nimport type {IDerivation} from './IDerivation'\nimport {isDerivation} from './IDerivation'\n\nexport default function* iterateOver<V>(\n  pointerOrDerivation: IDerivation<V> | Pointer<V>,\n): Generator<V, void, void> {\n  let d\n  if (isPointer(pointerOrDerivation)) {\n    d = valueDerivation(pointerOrDerivation) as IDerivation<V>\n  } else if (isDerivation(pointerOrDerivation)) {\n    d = pointerOrDerivation\n  } else {\n    throw new Error(`Only pointers and derivations are supported`)\n  }\n\n  const ticker = new Ticker()\n\n  const untap = d.changes(ticker).tap((v) => {})\n\n  try {\n    while (true) {\n      ticker.tick()\n\n      yield d.getValue()\n    }\n  } finally {\n    untap()\n  }\n}\n", "import Box from '../../Box'\nimport type {$IntentionalAny, VoidFn} from '../../types'\nimport Stack from '../../utils/Stack'\nimport AbstractDerivation from '../AbstractDerivation'\nimport type {IDerivation} from '../IDerivation'\nimport {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  pushCollector,\n  popCollector,\n} from './discoveryMechanism'\n\nconst voidFn = () => {}\n\nexport class PrismDerivation<V> extends AbstractDerivation<V> {\n  protected _cacheOfDendencyValues: Map<IDerivation<unknown>, unknown> =\n    new Map()\n  protected _possiblyStaleDeps = new Set<IDerivation<unknown>>()\n  private _prismScope = new PrismScope()\n\n  constructor(readonly _fn: () => V) {\n    super()\n  }\n\n  _recalculate() {\n    let value: V\n\n    if (this._possiblyStaleDeps.size > 0) {\n      let anActuallyStaleDepWasFound = false\n      startIgnoringDependencies()\n      for (const dep of this._possiblyStaleDeps) {\n        if (this._cacheOfDendencyValues.get(dep) !== dep.getValue()) {\n          anActuallyStaleDepWasFound = true\n          break\n        }\n      }\n      stopIgnoringDependencies()\n      this._possiblyStaleDeps.clear()\n      if (!anActuallyStaleDepWasFound) {\n        // console.log('ok')\n\n        return this._lastValue!\n      }\n    }\n\n    const newDeps: Set<IDerivation<unknown>> = new Set()\n    this._cacheOfDendencyValues.clear()\n\n    const collector = (observedDep: IDerivation<unknown>): void => {\n      newDeps.add(observedDep)\n      this._addDependency(observedDep)\n    }\n\n    pushCollector(collector)\n\n    hookScopeStack.push(this._prismScope)\n    try {\n      value = this._fn()\n    } catch (error) {\n      console.error(error)\n    } finally {\n      const topOfTheStack = hookScopeStack.pop()\n      if (topOfTheStack !== this._prismScope) {\n        console.warn(\n          // @todo guide the user to report the bug in an issue\n          `The Prism hook stack has slipped. This is a bug.`,\n        )\n      }\n    }\n\n    popCollector(collector)\n\n    this._dependencies.forEach((dep) => {\n      if (!newDeps.has(dep)) {\n        this._removeDependency(dep)\n      }\n    })\n\n    this._dependencies = newDeps\n\n    startIgnoringDependencies()\n    newDeps.forEach((dep) => {\n      this._cacheOfDendencyValues.set(dep, dep.getValue())\n    })\n    stopIgnoringDependencies()\n\n    return value!\n  }\n\n  _reactToDependencyBecomingStale(msgComingFrom: IDerivation<unknown>) {\n    this._possiblyStaleDeps.add(msgComingFrom)\n  }\n\n  _keepHot() {\n    this._prismScope = new PrismScope()\n    startIgnoringDependencies()\n    this.getValue()\n    stopIgnoringDependencies()\n  }\n\n  _becomeCold() {\n    cleanupScopeStack(this._prismScope)\n    this._prismScope = new PrismScope()\n  }\n}\n\nclass PrismScope {\n  isPrismScope = true\n  private _subs: Record<string, PrismScope> = {}\n\n  sub(key: string) {\n    if (!this._subs[key]) {\n      this._subs[key] = new PrismScope()\n    }\n    return this._subs[key]\n  }\n\n  get subs() {\n    return this._subs\n  }\n}\n\nfunction cleanupScopeStack(scope: PrismScope) {\n  for (const [_, sub] of Object.entries(scope.subs)) {\n    cleanupScopeStack(sub)\n  }\n  cleanupEffects(scope)\n}\n\nfunction cleanupEffects(scope: PrismScope) {\n  const effects = effectsWeakMap.get(scope)\n  if (effects) {\n    for (const k of Object.keys(effects)) {\n      const effect = effects[k]\n      safelyRun(effect.cleanup, undefined)\n    }\n  }\n  effectsWeakMap.delete(scope)\n}\n\nfunction safelyRun<T, U>(\n  fn: () => T,\n  returnValueInCaseOfError: U,\n): {success: boolean; returnValue: T | U} {\n  let returnValue: T | U = returnValueInCaseOfError\n  let success = false\n  try {\n    returnValue = fn()\n    success = true\n  } catch (error) {\n    setTimeout(() => {\n      throw error\n    })\n  }\n  return {success, returnValue}\n}\n\nconst hookScopeStack = new Stack<PrismScope>()\n\nconst refsWeakMap = new WeakMap<PrismScope, Record<string, IRef<unknown>>>()\n\ntype IRef<T> = {\n  current: T\n}\nconst effectsWeakMap = new WeakMap<PrismScope, Record<string, IEffect>>()\n\ntype IEffect = {\n  deps: undefined | unknown[]\n  cleanup: VoidFn\n}\n\nconst memosWeakMap = new WeakMap<PrismScope, Record<string, IMemo>>()\n\ntype IMemo = {\n  deps: undefined | unknown[] | ReadonlyArray<unknown>\n  cachedValue: unknown\n}\n\nfunction ref<T>(key: string, initialValue: T): IRef<T> {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.ref() is called outside of a prism() call.`)\n  }\n  let refs = refsWeakMap.get(scope)\n  if (!refs) {\n    refs = {}\n    refsWeakMap.set(scope, refs)\n  }\n\n  if (refs[key]) {\n    return refs[key] as $IntentionalAny as IRef<T>\n  } else {\n    const ref: IRef<T> = {\n      current: initialValue,\n    }\n    refs[key] = ref\n    return ref\n  }\n}\n\nfunction effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.effect() is called outside of a prism() call.`)\n  }\n  let effects = effectsWeakMap.get(scope)\n\n  if (!effects) {\n    effects = {}\n    effectsWeakMap.set(scope, effects)\n  }\n\n  if (!effects[key]) {\n    effects[key] = {\n      cleanup: voidFn,\n      deps: [{}],\n    }\n  }\n\n  const effect = effects[key]\n  if (depsHaveChanged(effect.deps, deps)) {\n    effect.cleanup()\n\n    startIgnoringDependencies()\n    effect.cleanup = safelyRun(cb, voidFn).returnValue\n    stopIgnoringDependencies()\n    effect.deps = deps\n  }\n}\n\nfunction depsHaveChanged(\n  oldDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n  newDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n): boolean {\n  if (oldDeps === undefined || newDeps === undefined) {\n    return true\n  } else if (oldDeps.length !== newDeps.length) {\n    return true\n  } else {\n    return oldDeps.some((el, i) => el !== newDeps[i])\n  }\n}\n\nfunction memo<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n): T {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.memo() is called outside of a prism() call.`)\n  }\n\n  let memos = memosWeakMap.get(scope)\n\n  if (!memos) {\n    memos = {}\n    memosWeakMap.set(scope, memos)\n  }\n\n  if (!memos[key]) {\n    memos[key] = {\n      cachedValue: null,\n      deps: [{}],\n    }\n  }\n\n  const memo = memos[key]\n  if (depsHaveChanged(memo.deps, deps)) {\n    startIgnoringDependencies()\n\n    memo.cachedValue = safelyRun(fn, undefined).returnValue\n    stopIgnoringDependencies()\n    memo.deps = deps\n  }\n\n  return memo.cachedValue as $IntentionalAny as T\n}\n\nfunction state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n  const {b, setValue} = prism.memo(\n    'state/' + key,\n    () => {\n      const b = new Box<T>(initialValue)\n      const setValue = (val: T) => b.set(val)\n      return {b, setValue}\n    },\n    [],\n  )\n\n  return [b.derivation.getValue(), setValue]\n}\n\nfunction ensurePrism(): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`The parent function is called outside of a prism() call.`)\n  }\n}\n\nfunction scope<T>(key: string, fn: () => T): T {\n  const parentScope = hookScopeStack.peek()\n  if (!parentScope) {\n    throw new Error(`prism.scope() is called outside of a prism() call.`)\n  }\n  const subScope = parentScope.sub(key)\n  hookScopeStack.push(subScope)\n  const ret = safelyRun(fn, undefined).returnValue\n  hookScopeStack.pop()\n  return ret as $IntentionalAny as T\n}\n\nfunction sub<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[],\n): T {\n  return memo(key, () => prism(fn), deps).getValue()\n}\n\nfunction inPrism(): boolean {\n  return !!hookScopeStack.peek()\n}\n\ntype IPrismFn = {\n  <T>(fn: () => T): IDerivation<T>\n  ref: typeof ref\n  effect: typeof effect\n  memo: typeof memo\n  ensurePrism: typeof ensurePrism\n  state: typeof state\n  scope: typeof scope\n  sub: typeof sub\n  inPrism: typeof inPrism\n}\n\nconst prism: IPrismFn = (fn) => {\n  return new PrismDerivation(fn)\n}\n\nprism.ref = ref\nprism.effect = effect\nprism.memo = memo\nprism.ensurePrism = ensurePrism\nprism.state = state\nprism.scope = scope\nprism.sub = sub\nprism.inPrism = inPrism\n\nexport default prism\n", "import type {IdentityDerivationProvider} from './Atom'\nimport type {Pointer} from './pointer'\nimport pointer from './pointer'\nimport type {IBox} from './Box'\nimport Box from './Box'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport {valueDerivation} from './Atom'\n\nexport default class PointerProxy<O extends {}>\n  implements IdentityDerivationProvider\n{\n  readonly $$isIdentityDerivationProvider = true\n  private readonly _currentPointerBox: IBox<Pointer<O>>\n  readonly pointer: Pointer<O>\n\n  constructor(currentPointer: Pointer<O>) {\n    this._currentPointerBox = new Box(currentPointer)\n    this.pointer = pointer({root: this as $FixMe, path: []})\n  }\n\n  setPointer(p: Pointer<O>) {\n    this._currentPointerBox.set(p)\n  }\n\n  getIdentityDerivation(path: Array<string | number>) {\n    return this._currentPointerBox.derivation.flatMap((p) => {\n      const subPointer = path.reduce(\n        (pointerSoFar, pathItem) => (pointerSoFar as $IntentionalAny)[pathItem],\n        p,\n      )\n      return valueDerivation(subPointer)\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
