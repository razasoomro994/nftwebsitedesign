declare type ICallback = (t: number) => void;
export default class Ticker {
    private _scheduledForThisOrNextTick;
    private _scheduledForNextTick;
    private _timeAtCurrentTick;
    private _ticking;
    constructor();
    /**
     * Registers for fn to be called either on this tick or the next tick.
     *
     * If registerSideEffect() is called while Ticker.tick() is running, the
     * side effect _will_ be called within the running tick. If you don't want this
     * behavior, you can use registerSideEffectForNextTick().
     *
     * Note that fn will be added to a Set(). Which means, if you call registerSideEffect(fn)
     * with the same fn twice in a single tick, it'll only run once.
     */
    onThisOrNextTick(fn: ICallback): void;
    /**
     * Registers a side effect to be called on the next tick.
     *
     * @see Ticker:onThisOrNextTick()
     */
    onNextTick(fn: ICallback): void;
    offThisOrNextTick(fn: ICallback): void;
    offNextTick(fn: ICallback): void;
    get time(): number;
    tick(t?: number): void;
    private _tick;
}
export {};
//# sourceMappingURL=Ticker.d.ts.map