import type { IDerivation } from './derivations/IDerivation';
import type { Pointer, PointerType } from './pointer';
import type { $FixMe } from './types';
import type { PathBasedReducer } from './utils/PathBasedReducer';
export interface IdentityDerivationProvider {
    readonly $$isIdentityDerivationProvider: true;
    getIdentityDerivation(path: Array<string | number>): IDerivation<unknown>;
}
export default class Atom<State extends {}> implements IdentityDerivationProvider {
    private _currentState;
    readonly $$isIdentityDerivationProvider = true;
    private readonly _rootScope;
    readonly pointer: Pointer<State>;
    constructor(initialState: State);
    setState(newState: State): void;
    getState(): State;
    getIn(path: (string | number)[]): unknown;
    reduceState: PathBasedReducer<State, State>;
    setIn(path: $FixMe[], val: $FixMe): State;
    private _checkUpdates;
    private _getOrCreateScopeForPath;
    private _onPathValueChange;
    getIdentityDerivation(path: Array<string | number>): IDerivation<unknown>;
}
export declare const valueDerivation: <P extends PointerType<any>>(pointer: P) => IDerivation<P extends PointerType<infer T> ? T : void>;
export declare const val: <P>(pointerOrDerivationOrPlainValue: P) => P extends PointerType<infer T> ? T : P extends IDerivation<infer T_1> ? T_1 : P extends null | undefined ? P : unknown;
//# sourceMappingURL=Atom.d.ts.map