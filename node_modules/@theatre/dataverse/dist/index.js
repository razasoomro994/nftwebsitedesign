var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  AbstractDerivation: () => AbstractDerivation,
  Atom: () => Atom,
  Box: () => Box,
  ConstantDerivation: () => ConstantDerivation,
  DerivationFromSource: () => DerivationFromSource,
  PointerProxy: () => PointerProxy,
  Ticker: () => Ticker,
  getPointerParts: () => getPointerParts,
  isDerivation: () => isDerivation,
  isPointer: () => isPointer,
  iterateAndCountTicks: () => iterateAndCountTicks,
  iterateOver: () => iterateOver,
  pointer: () => pointer_default,
  prism: () => prism_default,
  val: () => val,
  valueDerivation: () => valueDerivation
});

// src/Atom.ts
var import_get = __toModule(require("lodash-es/get"));
var import_isPlainObject = __toModule(require("lodash-es/isPlainObject"));
var import_last = __toModule(require("lodash-es/last"));

// src/utils/Tappable.ts
var Tappable = class {
  constructor(props) {
    this._untapFromSourceTimeout = null;
    this._cb = (arg) => {
      this._tappers.forEach((cb) => {
        cb(arg);
      });
    };
    this._lastTapperId = 0;
    this._untapFromSource = null;
    this._props = props;
    this._tappers = new Map();
  }
  _check() {
    if (this._untapFromSource) {
      if (this._tappers.size === 0) {
        this._scheduleToUntapFromSource();
      }
    } else {
      if (this._tappers.size !== 0) {
        this._untapFromSource = this._props.tapToSource(this._cb);
      }
    }
  }
  _scheduleToUntapFromSource() {
    if (this._untapFromSourceTimeout !== null)
      return;
    this._untapFromSourceTimeout = setTimeout(() => {
      this._untapFromSourceTimeout = null;
      if (this._tappers.size === 0) {
        this._untapFromSource();
        this._untapFromSource = null;
      }
    }, 0);
  }
  tap(cb) {
    const tapperId = this._lastTapperId++;
    this._tappers.set(tapperId, cb);
    this._check();
    return () => {
      this._removeTapperById(tapperId);
    };
  }
  _removeTapperById(id) {
    this._tappers.delete(id);
    this._check();
  }
};

// src/utils/Emitter.ts
var Emitter = class {
  constructor() {
    this._lastTapperId = 0;
    this._tappers = new Map();
    this.tappable = new Tappable({
      tapToSource: (cb) => {
        return this._tap(cb);
      }
    });
  }
  _tap(cb) {
    const tapperId = this._lastTapperId++;
    this._tappers.set(tapperId, cb);
    this._onNumberOfTappersChangeListener && this._onNumberOfTappersChangeListener(this._tappers.size);
    return () => {
      this._removeTapperById(tapperId);
    };
  }
  _removeTapperById(id) {
    const oldSize = this._tappers.size;
    this._tappers.delete(id);
    const newSize = this._tappers.size;
    if (oldSize !== newSize) {
      this._onNumberOfTappersChangeListener && this._onNumberOfTappersChangeListener(this._tappers.size);
    }
  }
  emit(payload) {
    this._tappers.forEach((cb) => {
      cb(payload);
    });
  }
  hasTappers() {
    return this._tappers.size !== 0;
  }
  onNumberOfTappersChange(cb) {
    this._onNumberOfTappersChangeListener = cb;
  }
};

// src/derivations/DerivationEmitter.ts
var DerivationEmitter = class {
  constructor(derivation, ticker) {
    this._possiblyMarkAsStale = () => {
      this._ticker.onThisOrNextTick(this._refresh);
    };
    this._refresh = () => {
      const newValue = this._derivation.getValue();
      if (newValue === this._lastValue && this._lastValueRecorded === true)
        return;
      this._lastValue = newValue;
      this._lastValueRecorded = true;
      this._emitter.emit(newValue);
    };
    this._derivation = derivation;
    this._ticker = ticker;
    this._emitter = new Emitter();
    this._emitter.onNumberOfTappersChange(() => {
      this._reactToNumberOfTappersChange();
    });
    this._hadTappers = false;
    this._lastValueRecorded = false;
    this._lastValue = void 0;
    return this;
  }
  _reactToNumberOfTappersChange() {
    const hasTappers = this._emitter.hasTappers();
    if (hasTappers !== this._hadTappers) {
      this._hadTappers = hasTappers;
      if (hasTappers) {
        this._derivation.addDependent(this._possiblyMarkAsStale);
      } else {
        this._derivation.removeDependent(this._possiblyMarkAsStale);
      }
    }
  }
  tappable() {
    return this._emitter.tappable;
  }
};

// src/derivations/DerivationValuelessEmitter.ts
var DerivationValuelessEmitter = class {
  constructor(derivation, dontEmitValues = false) {
    this.dontEmitValues = dontEmitValues;
    this._possiblyMarkAsStale = () => {
      this._emitter.emit(void 0);
    };
    this._derivation = derivation;
    this._emitter = new Emitter();
    this._emitter.onNumberOfTappersChange(() => {
      this._reactToNumberOfTappersChange();
    });
    this._hadTappers = false;
    return this;
  }
  _reactToNumberOfTappersChange() {
    const hasTappers = this._emitter.hasTappers();
    if (hasTappers !== this._hadTappers) {
      this._hadTappers = hasTappers;
      if (hasTappers) {
        this._derivation.addDependent(this._possiblyMarkAsStale);
      } else {
        this._derivation.removeDependent(this._possiblyMarkAsStale);
      }
    }
  }
  tappable() {
    return this._emitter.tappable;
  }
};

// src/derivations/IDerivation.ts
function isDerivation(d) {
  return d && d.isDerivation && d.isDerivation === true;
}

// src/derivations/flatMap.ts
var UPDATE_NEEDED_FROM;
(function(UPDATE_NEEDED_FROM2) {
  UPDATE_NEEDED_FROM2[UPDATE_NEEDED_FROM2["none"] = 0] = "none";
  UPDATE_NEEDED_FROM2[UPDATE_NEEDED_FROM2["dep"] = 1] = "dep";
  UPDATE_NEEDED_FROM2[UPDATE_NEEDED_FROM2["inner"] = 2] = "inner";
})(UPDATE_NEEDED_FROM || (UPDATE_NEEDED_FROM = {}));
var makeFlatMapDerivationClass = () => {
  class FlatMapDerivation extends AbstractDerivation {
    constructor(_depDerivation, _fn) {
      super();
      this._depDerivation = _depDerivation;
      this._fn = _fn;
      this._innerDerivation = void 0;
      this._staleDependency = 1;
      this._addDependency(_depDerivation);
      return this;
    }
    _recalculateHot() {
      const updateNeededFrom = this._staleDependency;
      this._staleDependency = 0;
      if (updateNeededFrom === 2) {
        return this._innerDerivation.getValue();
      }
      const possibleInnerDerivation = this._fn(this._depDerivation.getValue());
      if (isDerivation(possibleInnerDerivation)) {
        this._innerDerivation = possibleInnerDerivation;
        this._addDependency(possibleInnerDerivation);
        return possibleInnerDerivation.getValue();
      } else {
        return possibleInnerDerivation;
      }
    }
    _recalculateCold() {
      const possibleInnerDerivation = this._fn(this._depDerivation.getValue());
      if (isDerivation(possibleInnerDerivation)) {
        return possibleInnerDerivation.getValue();
      } else {
        return possibleInnerDerivation;
      }
    }
    _recalculate() {
      return this.isHot ? this._recalculateHot() : this._recalculateCold();
    }
    _reactToDependencyBecomingStale(msgComingFrom) {
      const updateNeededFrom = msgComingFrom === this._depDerivation ? 1 : 2;
      if (updateNeededFrom === 2 && msgComingFrom !== this._innerDerivation) {
        throw Error(`got a _reactToDependencyBecomingStale() from neither the dep nor the inner derivation`);
      }
      if (this._staleDependency === 0) {
        this._staleDependency = updateNeededFrom;
        if (updateNeededFrom === 1) {
          this._removeInnerDerivation();
        }
      } else if (this._staleDependency === 1) {
      } else {
        if (updateNeededFrom === 1) {
          this._staleDependency = 1;
          this._removeInnerDerivation();
        }
      }
    }
    _removeInnerDerivation() {
      if (this._innerDerivation) {
        this._removeDependency(this._innerDerivation);
        this._innerDerivation = void 0;
      }
    }
    _keepHot() {
      this._staleDependency = 1;
      this.getValue();
    }
    _becomeCold() {
      this._staleDependency = 1;
      this._removeInnerDerivation();
    }
  }
  FlatMapDerivation.displayName = "flatMap";
  return FlatMapDerivation;
};
var cls = void 0;
function flatMap(dep, fn) {
  if (!cls) {
    cls = makeFlatMapDerivationClass();
  }
  return new cls(dep, fn);
}

// src/derivations/map.ts
var makeMapDerivationClass = () => class MapDerivation extends AbstractDerivation {
  constructor(_dep, _fn) {
    super();
    this._dep = _dep;
    this._fn = _fn;
    this._addDependency(_dep);
  }
  _recalculate() {
    return this._fn(this._dep.getValue());
  }
  _reactToDependencyBecomingStale() {
  }
};
var cls2 = void 0;
function flatMap2(dep, fn) {
  if (!cls2) {
    cls2 = makeMapDerivationClass();
  }
  return new cls2(dep, fn);
}

// src/utils/Stack.ts
var Stack = class {
  constructor() {
    this._head = void 0;
  }
  peek() {
    return this._head && this._head.data;
  }
  pop() {
    const head = this._head;
    if (!head) {
      return void 0;
    }
    this._head = head.next;
    return head.data;
  }
  push(data) {
    const node = { next: this._head, data };
    this._head = node;
  }
};

// src/derivations/prism/discoveryMechanism.ts
function createMechanism() {
  const noop2 = () => {
  };
  const stack = new Stack();
  const noopCollector = noop2;
  const pushCollector2 = (collector) => {
    stack.push(collector);
  };
  const popCollector2 = (collector) => {
    const existing = stack.peek();
    if (existing !== collector) {
      throw new Error(`Popped collector is not on top of the stack`);
    }
    stack.pop();
  };
  const startIgnoringDependencies2 = () => {
    stack.push(noopCollector);
  };
  const stopIgnoringDependencies2 = () => {
    if (stack.peek() !== noopCollector) {
      if (process.env.NODE_ENV === "development") {
        console.warn("This should never happen");
      }
    } else {
      stack.pop();
    }
  };
  const reportResolutionStart2 = (d) => {
    const possibleCollector = stack.peek();
    if (possibleCollector) {
      possibleCollector(d);
    }
    stack.push(noopCollector);
  };
  const reportResolutionEnd2 = (_d) => {
    stack.pop();
  };
  return {
    type: "Dataverse_discoveryMechanism",
    startIgnoringDependencies: startIgnoringDependencies2,
    stopIgnoringDependencies: stopIgnoringDependencies2,
    reportResolutionStart: reportResolutionStart2,
    reportResolutionEnd: reportResolutionEnd2,
    pushCollector: pushCollector2,
    popCollector: popCollector2
  };
}
function getSharedMechanism() {
  const varName = "__dataverse_discoveryMechanism_sharedStack";
  if (window) {
    const existingMechanism = window[varName];
    if (existingMechanism && typeof existingMechanism === "object" && existingMechanism.type === "Dataverse_discoveryMechanism") {
      return existingMechanism;
    } else {
      const mechanism = createMechanism();
      window[varName] = mechanism;
      return mechanism;
    }
  } else {
    return createMechanism();
  }
}
var {
  startIgnoringDependencies,
  stopIgnoringDependencies,
  reportResolutionEnd,
  reportResolutionStart,
  pushCollector,
  popCollector
} = getSharedMechanism();

// src/derivations/AbstractDerivation.ts
var AbstractDerivation = class {
  constructor() {
    this.isDerivation = true;
    this._didMarkDependentsAsStale = false;
    this._isHot = false;
    this._isFresh = false;
    this._lastValue = void 0;
    this._dependents = new Set();
    this._dependencies = new Set();
    this._internal_markAsStale = (which) => {
      this._reactToDependencyBecomingStale(which);
      if (this._didMarkDependentsAsStale)
        return;
      this._didMarkDependentsAsStale = true;
      this._isFresh = false;
      this._dependents.forEach((dependent) => {
        dependent(this);
      });
    };
  }
  get isHot() {
    return this._isHot;
  }
  _addDependency(d) {
    if (this._dependencies.has(d))
      return;
    this._dependencies.add(d);
    if (this._isHot)
      d.addDependent(this._internal_markAsStale);
  }
  _removeDependency(d) {
    if (!this._dependencies.has(d))
      return;
    this._dependencies.delete(d);
    if (this._isHot)
      d.removeDependent(this._internal_markAsStale);
  }
  changes(ticker) {
    return new DerivationEmitter(this, ticker).tappable();
  }
  changesWithoutValues() {
    return new DerivationValuelessEmitter(this).tappable();
  }
  keepHot() {
    return this.changesWithoutValues().tap(() => {
    });
  }
  tapImmediate(ticker, fn) {
    const untap = this.changes(ticker).tap(fn);
    fn(this.getValue());
    return untap;
  }
  addDependent(d) {
    const hadDepsBefore = this._dependents.size > 0;
    this._dependents.add(d);
    const hasDepsNow = this._dependents.size > 0;
    if (hadDepsBefore !== hasDepsNow) {
      this._reactToNumberOfDependentsChange();
    }
  }
  removeDependent(d) {
    const hadDepsBefore = this._dependents.size > 0;
    this._dependents.delete(d);
    const hasDepsNow = this._dependents.size > 0;
    if (hadDepsBefore !== hasDepsNow) {
      this._reactToNumberOfDependentsChange();
    }
  }
  _markAsStale(which) {
    this._internal_markAsStale(which);
  }
  getValue() {
    reportResolutionStart(this);
    if (!this._isFresh) {
      const newValue = this._recalculate();
      this._lastValue = newValue;
      if (this._isHot) {
        this._isFresh = true;
        this._didMarkDependentsAsStale = false;
      }
    }
    reportResolutionEnd(this);
    return this._lastValue;
  }
  _reactToNumberOfDependentsChange() {
    const shouldBecomeHot = this._dependents.size > 0;
    if (shouldBecomeHot === this._isHot)
      return;
    this._isHot = shouldBecomeHot;
    this._didMarkDependentsAsStale = false;
    this._isFresh = false;
    if (shouldBecomeHot) {
      this._dependencies.forEach((d) => {
        d.addDependent(this._internal_markAsStale);
      });
      this._keepHot();
    } else {
      this._dependencies.forEach((d) => {
        d.removeDependent(this._internal_markAsStale);
      });
      this._becomeCold();
    }
  }
  _keepHot() {
  }
  _becomeCold() {
  }
  map(fn) {
    return flatMap2(this, fn);
  }
  flatMap(fn) {
    return flatMap(this, fn);
  }
};

// src/derivations/DerivationFromSource.ts
var noop = () => {
};
var DerivationFromSource = class extends AbstractDerivation {
  constructor(_tapToSource, _getValueFromSource) {
    super();
    this._tapToSource = _tapToSource;
    this._getValueFromSource = _getValueFromSource;
    this._untapFromChanges = noop;
    this._cachedValue = void 0;
    this._hasCachedValue = false;
  }
  _recalculate() {
    if (this.isHot) {
      if (!this._hasCachedValue) {
        this._cachedValue = this._getValueFromSource();
        this._hasCachedValue = true;
      }
      return this._cachedValue;
    } else {
      return this._getValueFromSource();
    }
  }
  _keepHot() {
    this._hasCachedValue = false;
    this._cachedValue = void 0;
    this._untapFromChanges = this._tapToSource((newValue) => {
      this._hasCachedValue = true;
      this._cachedValue = newValue;
      this._markAsStale(this);
    });
  }
  _becomeCold() {
    this._untapFromChanges();
    this._untapFromChanges = noop;
    this._hasCachedValue = false;
    this._cachedValue = void 0;
  }
  _reactToDependencyBecomingStale() {
  }
};

// src/pointer.ts
var pointerMetaWeakMap = new WeakMap();
var pointerMetaSymbol = Symbol("pointerMeta");
var cachedSubPointersWeakMap = new WeakMap();
var handler = {
  get(obj, prop) {
    if (prop === pointerMetaSymbol)
      return pointerMetaWeakMap.get(obj);
    let subs = cachedSubPointersWeakMap.get(obj);
    if (!subs) {
      subs = {};
      cachedSubPointersWeakMap.set(obj, subs);
    }
    if (subs[prop])
      return subs[prop];
    const meta = pointerMetaWeakMap.get(obj);
    const subPointer = pointer({ root: meta.root, path: [...meta.path, prop] });
    subs[prop] = subPointer;
    return subPointer;
  }
};
var getPointerMeta = (p) => {
  const meta = p[pointerMetaSymbol];
  return meta;
};
var getPointerParts = (p) => {
  const { root, path } = getPointerMeta(p);
  return { root, path };
};
function pointer(args) {
  var _a;
  const meta = {
    root: args.root,
    path: (_a = args.path) != null ? _a : []
  };
  const hiddenObj = {};
  pointerMetaWeakMap.set(hiddenObj, meta);
  return new Proxy(hiddenObj, handler);
}
var pointer_default = pointer;
var isPointer = (p) => {
  return p && !!getPointerMeta(p);
};

// src/utils/updateDeep.ts
function updateDeep(state2, path, reducer) {
  if (path.length === 0)
    return reducer(state2);
  return hoop(state2, path, reducer);
}
var hoop = (s, path, reducer) => {
  if (path.length === 0) {
    return reducer(s);
  }
  if (Array.isArray(s)) {
    let [index, ...restOfPath] = path;
    index = parseInt(String(index), 10);
    if (isNaN(index))
      index = 0;
    const oldVal = s[index];
    const newVal = hoop(oldVal, restOfPath, reducer);
    if (oldVal === newVal)
      return s;
    const newS = [...s];
    newS.splice(index, 1, newVal);
    return newS;
  } else if (typeof s === "object" && s !== null) {
    const [key, ...restOfPath] = path;
    const oldVal = s[key];
    const newVal = hoop(oldVal, restOfPath, reducer);
    if (oldVal === newVal)
      return s;
    const newS = __spreadProps(__spreadValues({}, s), { [key]: newVal });
    return newS;
  } else {
    const [key, ...restOfPath] = path;
    return { [key]: hoop(void 0, restOfPath, reducer) };
  }
};

// src/Atom.ts
var ValueTypes;
(function(ValueTypes2) {
  ValueTypes2[ValueTypes2["Dict"] = 0] = "Dict";
  ValueTypes2[ValueTypes2["Array"] = 1] = "Array";
  ValueTypes2[ValueTypes2["Other"] = 2] = "Other";
})(ValueTypes || (ValueTypes = {}));
var getTypeOfValue = (v) => {
  if (Array.isArray(v))
    return 1;
  if ((0, import_isPlainObject.default)(v))
    return 0;
  return 2;
};
var getKeyOfValue = (v, key, vType = getTypeOfValue(v)) => {
  if (vType === 0 && typeof key === "string") {
    return v[key];
  } else if (vType === 1 && isValidArrayIndex(key)) {
    return v[key];
  } else {
    return void 0;
  }
};
var isValidArrayIndex = (key) => {
  const inNumber = typeof key === "number" ? key : parseInt(key, 10);
  return !isNaN(inNumber) && inNumber >= 0 && inNumber < Infinity && (inNumber | 0) === inNumber;
};
var Scope = class {
  constructor(_parent, _path) {
    this._parent = _parent;
    this._path = _path;
    this.children = new Map();
    this.identityChangeListeners = new Set();
  }
  addIdentityChangeListener(cb) {
    this.identityChangeListeners.add(cb);
  }
  removeIdentityChangeListener(cb) {
    this.identityChangeListeners.delete(cb);
    this._checkForGC();
  }
  removeChild(key) {
    this.children.delete(key);
    this._checkForGC();
  }
  getChild(key) {
    return this.children.get(key);
  }
  getOrCreateChild(key) {
    let child = this.children.get(key);
    if (!child) {
      child = child = new Scope(this, this._path.concat([key]));
      this.children.set(key, child);
    }
    return child;
  }
  _checkForGC() {
    if (this.identityChangeListeners.size > 0)
      return;
    if (this.children.size > 0)
      return;
    if (this._parent) {
      this._parent.removeChild((0, import_last.default)(this._path));
    }
  }
};
var Atom = class {
  constructor(initialState) {
    this.$$isIdentityDerivationProvider = true;
    this.reduceState = (path, reducer) => {
      const newState = updateDeep(this.getState(), path, reducer);
      this.setState(newState);
      return newState;
    };
    this._onPathValueChange = (path, cb) => {
      const scope2 = this._getOrCreateScopeForPath(path);
      scope2.identityChangeListeners.add(cb);
      const untap = () => {
        scope2.identityChangeListeners.delete(cb);
      };
      return untap;
    };
    this._currentState = initialState;
    this._rootScope = new Scope(void 0, []);
    this.pointer = pointer_default({ root: this, path: [] });
  }
  setState(newState) {
    const oldState = this._currentState;
    this._currentState = newState;
    this._checkUpdates(this._rootScope, oldState, newState);
  }
  getState() {
    return this._currentState;
  }
  getIn(path) {
    return path.length === 0 ? this.getState() : (0, import_get.default)(this.getState(), path);
  }
  setIn(path, val2) {
    return this.reduceState(path, () => val2);
  }
  _checkUpdates(scope2, oldState, newState) {
    if (oldState === newState)
      return;
    scope2.identityChangeListeners.forEach((cb) => cb(newState));
    if (scope2.children.size === 0)
      return;
    const oldValueType = getTypeOfValue(oldState);
    const newValueType = getTypeOfValue(newState);
    if (oldValueType === 2 && oldValueType === newValueType)
      return;
    scope2.children.forEach((childScope, childKey) => {
      const oldChildVal = getKeyOfValue(oldState, childKey, oldValueType);
      const newChildVal = getKeyOfValue(newState, childKey, newValueType);
      this._checkUpdates(childScope, oldChildVal, newChildVal);
    });
  }
  _getOrCreateScopeForPath(path) {
    let curScope = this._rootScope;
    for (const pathEl of path) {
      curScope = curScope.getOrCreateChild(pathEl);
    }
    return curScope;
  }
  getIdentityDerivation(path) {
    return new DerivationFromSource((listener) => this._onPathValueChange(path, listener), () => this.getIn(path));
  }
};
var identityDerivationWeakMap = new WeakMap();
var valueDerivation = (pointer2) => {
  const meta = getPointerMeta(pointer2);
  let derivation = identityDerivationWeakMap.get(meta);
  if (!derivation) {
    const root = meta.root;
    if (!isIdentityChangeProvider(root)) {
      throw new Error(`Cannot run valueDerivation() on a pointer whose root is not an IdentityChangeProvider`);
    }
    const { path } = meta;
    derivation = root.getIdentityDerivation(path);
    identityDerivationWeakMap.set(meta, derivation);
  }
  return derivation;
};
function isIdentityChangeProvider(val2) {
  return typeof val2 === "object" && val2 !== null && val2["$$isIdentityDerivationProvider"] === true;
}
var val = (pointerOrDerivationOrPlainValue) => {
  if (isPointer(pointerOrDerivationOrPlainValue)) {
    return valueDerivation(pointerOrDerivationOrPlainValue).getValue();
  } else if (isDerivation(pointerOrDerivationOrPlainValue)) {
    return pointerOrDerivationOrPlainValue.getValue();
  } else {
    return pointerOrDerivationOrPlainValue;
  }
};

// src/Box.ts
var Box = class {
  constructor(_value) {
    this._value = _value;
    this._emitter = new Emitter();
    this._publicDerivation = new DerivationFromSource((listener) => this._emitter.tappable.tap(listener), this.get.bind(this));
  }
  set(v) {
    if (v === this._value)
      return;
    this._value = v;
    this._emitter.emit(v);
  }
  get() {
    return this._value;
  }
  get derivation() {
    return this._publicDerivation;
  }
};

// src/derivations/ConstantDerivation.ts
var ConstantDerivation = class extends AbstractDerivation {
  constructor(v) {
    super();
    this._v = v;
    return this;
  }
  _recalculate() {
    return this._v;
  }
  _reactToDependencyBecomingStale() {
  }
};

// src/derivations/iterateAndCountTicks.ts
function* iterateAndCountTicks(pointerOrDerivation) {
  let d;
  if (isPointer(pointerOrDerivation)) {
    d = valueDerivation(pointerOrDerivation);
  } else if (isDerivation(pointerOrDerivation)) {
    d = pointerOrDerivation;
  } else {
    throw new Error(`Only pointers and derivations are supported`);
  }
  let ticksCountedSinceLastYield = 0;
  const untap = d.changesWithoutValues().tap(() => {
    ticksCountedSinceLastYield++;
  });
  try {
    while (true) {
      const ticks = ticksCountedSinceLastYield;
      ticksCountedSinceLastYield = 0;
      yield { value: d.getValue(), ticks };
    }
  } finally {
    untap();
  }
}

// src/Ticker.ts
var Ticker = class {
  constructor() {
    this._ticking = false;
    this._scheduledForThisOrNextTick = new Set();
    this._scheduledForNextTick = new Set();
    this._timeAtCurrentTick = 0;
  }
  onThisOrNextTick(fn) {
    this._scheduledForThisOrNextTick.add(fn);
  }
  onNextTick(fn) {
    this._scheduledForNextTick.add(fn);
  }
  offThisOrNextTick(fn) {
    this._scheduledForThisOrNextTick.delete(fn);
  }
  offNextTick(fn) {
    this._scheduledForNextTick.delete(fn);
  }
  get time() {
    if (this._ticking) {
      return this._timeAtCurrentTick;
    } else
      return performance.now();
  }
  tick(t = performance.now()) {
    this._ticking = true;
    this._timeAtCurrentTick = t;
    this._scheduledForNextTick.forEach((v) => this._scheduledForThisOrNextTick.add(v));
    this._scheduledForNextTick.clear();
    this._tick(0);
    this._ticking = false;
  }
  _tick(iterationNumber) {
    const time = this.time;
    if (iterationNumber > 10) {
      console.warn("_tick() recursing for 10 times");
    }
    if (iterationNumber > 100) {
      throw new Error(`Maximum recursion limit for _tick()`);
    }
    const oldSet = this._scheduledForThisOrNextTick;
    this._scheduledForThisOrNextTick = new Set();
    oldSet.forEach((fn) => {
      fn(time);
    });
    if (this._scheduledForThisOrNextTick.size > 0) {
      return this._tick(iterationNumber + 1);
    }
  }
};

// src/derivations/iterateOver.ts
function* iterateOver(pointerOrDerivation) {
  let d;
  if (isPointer(pointerOrDerivation)) {
    d = valueDerivation(pointerOrDerivation);
  } else if (isDerivation(pointerOrDerivation)) {
    d = pointerOrDerivation;
  } else {
    throw new Error(`Only pointers and derivations are supported`);
  }
  const ticker = new Ticker();
  const untap = d.changes(ticker).tap((v) => {
  });
  try {
    while (true) {
      ticker.tick();
      yield d.getValue();
    }
  } finally {
    untap();
  }
}

// src/derivations/prism/prism.ts
var voidFn = () => {
};
var PrismDerivation = class extends AbstractDerivation {
  constructor(_fn) {
    super();
    this._fn = _fn;
    this._cacheOfDendencyValues = new Map();
    this._possiblyStaleDeps = new Set();
    this._prismScope = new PrismScope();
  }
  _recalculate() {
    let value;
    if (this._possiblyStaleDeps.size > 0) {
      let anActuallyStaleDepWasFound = false;
      startIgnoringDependencies();
      for (const dep of this._possiblyStaleDeps) {
        if (this._cacheOfDendencyValues.get(dep) !== dep.getValue()) {
          anActuallyStaleDepWasFound = true;
          break;
        }
      }
      stopIgnoringDependencies();
      this._possiblyStaleDeps.clear();
      if (!anActuallyStaleDepWasFound) {
        return this._lastValue;
      }
    }
    const newDeps = new Set();
    this._cacheOfDendencyValues.clear();
    const collector = (observedDep) => {
      newDeps.add(observedDep);
      this._addDependency(observedDep);
    };
    pushCollector(collector);
    hookScopeStack.push(this._prismScope);
    try {
      value = this._fn();
    } catch (error) {
      console.error(error);
    } finally {
      const topOfTheStack = hookScopeStack.pop();
      if (topOfTheStack !== this._prismScope) {
        console.warn(`The Prism hook stack has slipped. This is a bug.`);
      }
    }
    popCollector(collector);
    this._dependencies.forEach((dep) => {
      if (!newDeps.has(dep)) {
        this._removeDependency(dep);
      }
    });
    this._dependencies = newDeps;
    startIgnoringDependencies();
    newDeps.forEach((dep) => {
      this._cacheOfDendencyValues.set(dep, dep.getValue());
    });
    stopIgnoringDependencies();
    return value;
  }
  _reactToDependencyBecomingStale(msgComingFrom) {
    this._possiblyStaleDeps.add(msgComingFrom);
  }
  _keepHot() {
    this._prismScope = new PrismScope();
    startIgnoringDependencies();
    this.getValue();
    stopIgnoringDependencies();
  }
  _becomeCold() {
    cleanupScopeStack(this._prismScope);
    this._prismScope = new PrismScope();
  }
};
var PrismScope = class {
  constructor() {
    this.isPrismScope = true;
    this._subs = {};
  }
  sub(key) {
    if (!this._subs[key]) {
      this._subs[key] = new PrismScope();
    }
    return this._subs[key];
  }
  get subs() {
    return this._subs;
  }
};
function cleanupScopeStack(scope2) {
  for (const [_, sub2] of Object.entries(scope2.subs)) {
    cleanupScopeStack(sub2);
  }
  cleanupEffects(scope2);
}
function cleanupEffects(scope2) {
  const effects = effectsWeakMap.get(scope2);
  if (effects) {
    for (const k of Object.keys(effects)) {
      const effect2 = effects[k];
      safelyRun(effect2.cleanup, void 0);
    }
  }
  effectsWeakMap.delete(scope2);
}
function safelyRun(fn, returnValueInCaseOfError) {
  let returnValue = returnValueInCaseOfError;
  let success = false;
  try {
    returnValue = fn();
    success = true;
  } catch (error) {
    setTimeout(() => {
      throw error;
    });
  }
  return { success, returnValue };
}
var hookScopeStack = new Stack();
var refsWeakMap = new WeakMap();
var effectsWeakMap = new WeakMap();
var memosWeakMap = new WeakMap();
function ref(key, initialValue) {
  const scope2 = hookScopeStack.peek();
  if (!scope2) {
    throw new Error(`prism.ref() is called outside of a prism() call.`);
  }
  let refs = refsWeakMap.get(scope2);
  if (!refs) {
    refs = {};
    refsWeakMap.set(scope2, refs);
  }
  if (refs[key]) {
    return refs[key];
  } else {
    const ref2 = {
      current: initialValue
    };
    refs[key] = ref2;
    return ref2;
  }
}
function effect(key, cb, deps) {
  const scope2 = hookScopeStack.peek();
  if (!scope2) {
    throw new Error(`prism.effect() is called outside of a prism() call.`);
  }
  let effects = effectsWeakMap.get(scope2);
  if (!effects) {
    effects = {};
    effectsWeakMap.set(scope2, effects);
  }
  if (!effects[key]) {
    effects[key] = {
      cleanup: voidFn,
      deps: [{}]
    };
  }
  const effect2 = effects[key];
  if (depsHaveChanged(effect2.deps, deps)) {
    effect2.cleanup();
    startIgnoringDependencies();
    effect2.cleanup = safelyRun(cb, voidFn).returnValue;
    stopIgnoringDependencies();
    effect2.deps = deps;
  }
}
function depsHaveChanged(oldDeps, newDeps) {
  if (oldDeps === void 0 || newDeps === void 0) {
    return true;
  } else if (oldDeps.length !== newDeps.length) {
    return true;
  } else {
    return oldDeps.some((el, i) => el !== newDeps[i]);
  }
}
function memo(key, fn, deps) {
  const scope2 = hookScopeStack.peek();
  if (!scope2) {
    throw new Error(`prism.memo() is called outside of a prism() call.`);
  }
  let memos = memosWeakMap.get(scope2);
  if (!memos) {
    memos = {};
    memosWeakMap.set(scope2, memos);
  }
  if (!memos[key]) {
    memos[key] = {
      cachedValue: null,
      deps: [{}]
    };
  }
  const memo2 = memos[key];
  if (depsHaveChanged(memo2.deps, deps)) {
    startIgnoringDependencies();
    memo2.cachedValue = safelyRun(fn, void 0).returnValue;
    stopIgnoringDependencies();
    memo2.deps = deps;
  }
  return memo2.cachedValue;
}
function state(key, initialValue) {
  const { b, setValue } = prism.memo("state/" + key, () => {
    const b2 = new Box(initialValue);
    const setValue2 = (val2) => b2.set(val2);
    return { b: b2, setValue: setValue2 };
  }, []);
  return [b.derivation.getValue(), setValue];
}
function ensurePrism() {
  const scope2 = hookScopeStack.peek();
  if (!scope2) {
    throw new Error(`The parent function is called outside of a prism() call.`);
  }
}
function scope(key, fn) {
  const parentScope = hookScopeStack.peek();
  if (!parentScope) {
    throw new Error(`prism.scope() is called outside of a prism() call.`);
  }
  const subScope = parentScope.sub(key);
  hookScopeStack.push(subScope);
  const ret = safelyRun(fn, void 0).returnValue;
  hookScopeStack.pop();
  return ret;
}
function sub(key, fn, deps) {
  return memo(key, () => prism(fn), deps).getValue();
}
function inPrism() {
  return !!hookScopeStack.peek();
}
var prism = (fn) => {
  return new PrismDerivation(fn);
};
prism.ref = ref;
prism.effect = effect;
prism.memo = memo;
prism.ensurePrism = ensurePrism;
prism.state = state;
prism.scope = scope;
prism.sub = sub;
prism.inPrism = inPrism;
var prism_default = prism;

// src/PointerProxy.ts
var PointerProxy = class {
  constructor(currentPointer) {
    this.$$isIdentityDerivationProvider = true;
    this._currentPointerBox = new Box(currentPointer);
    this.pointer = pointer_default({ root: this, path: [] });
  }
  setPointer(p) {
    this._currentPointerBox.set(p);
  }
  getIdentityDerivation(path) {
    return this._currentPointerBox.derivation.flatMap((p) => {
      const subPointer = path.reduce((pointerSoFar, pathItem) => pointerSoFar[pathItem], p);
      return valueDerivation(subPointer);
    });
  }
};
//# sourceMappingURL=index.js.map
