import type Ticker from '../Ticker';
import type { $IntentionalAny, VoidFn } from '../types';
import type Tappable from '../utils/Tappable';
import type { IDerivation } from './IDerivation';
declare type IDependent = (msgComingFrom: IDerivation<$IntentionalAny>) => void;
export default abstract class AbstractDerivation<V> implements IDerivation<V> {
    readonly isDerivation: true;
    private _didMarkDependentsAsStale;
    private _isHot;
    private _isFresh;
    protected _lastValue: undefined | V;
    protected _dependents: Set<IDependent>;
    protected _dependencies: Set<IDerivation<$IntentionalAny>>;
    protected abstract _recalculate(): V;
    protected abstract _reactToDependencyBecomingStale(which: IDerivation<unknown>): void;
    constructor();
    get isHot(): boolean;
    protected _addDependency(d: IDerivation<$IntentionalAny>): void;
    protected _removeDependency(d: IDerivation<$IntentionalAny>): void;
    changes(ticker: Ticker): Tappable<V>;
    changesWithoutValues(): Tappable<void>;
    keepHot(): () => void;
    tapImmediate(ticker: Ticker, fn: (cb: V) => void): VoidFn;
    addDependent(d: IDependent): void;
    /**
     * @sealed
     */
    removeDependent(d: IDependent): void;
    /**
     * This is meant to be called by subclasses
     *
     * @sealed
     */
    protected _markAsStale(which: IDerivation<$IntentionalAny>): void;
    private _internal_markAsStale;
    getValue(): V;
    private _reactToNumberOfDependentsChange;
    protected _keepHot(): void;
    protected _becomeCold(): void;
    map<T>(fn: (v: V) => T): IDerivation<T>;
    flatMap<R>(fn: (v: V) => R): IDerivation<R extends IDerivation<infer T> ? T : R>;
}
export {};
//# sourceMappingURL=AbstractDerivation.d.ts.map