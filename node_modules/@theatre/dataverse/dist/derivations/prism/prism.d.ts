import type { $IntentionalAny } from '../../types';
import AbstractDerivation from '../AbstractDerivation';
import type { IDerivation } from '../IDerivation';
export declare class PrismDerivation<V> extends AbstractDerivation<V> {
    readonly _fn: () => V;
    protected _cacheOfDendencyValues: Map<IDerivation<unknown>, unknown>;
    protected _possiblyStaleDeps: Set<IDerivation<unknown>>;
    private _prismScope;
    constructor(_fn: () => V);
    _recalculate(): NonNullable<V>;
    _reactToDependencyBecomingStale(msgComingFrom: IDerivation<unknown>): void;
    _keepHot(): void;
    _becomeCold(): void;
}
declare type IRef<T> = {
    current: T;
};
declare function ref<T>(key: string, initialValue: T): IRef<T>;
declare function effect(key: string, cb: () => () => void, deps?: unknown[]): void;
declare function memo<T>(key: string, fn: () => T, deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>): T;
declare function state<T>(key: string, initialValue: T): [T, (val: T) => void];
declare function ensurePrism(): void;
declare function scope<T>(key: string, fn: () => T): T;
declare function sub<T>(key: string, fn: () => T, deps: undefined | $IntentionalAny[]): T;
declare function inPrism(): boolean;
declare type IPrismFn = {
    <T>(fn: () => T): IDerivation<T>;
    ref: typeof ref;
    effect: typeof effect;
    memo: typeof memo;
    ensurePrism: typeof ensurePrism;
    state: typeof state;
    scope: typeof scope;
    sub: typeof sub;
    inPrism: typeof inPrism;
};
declare const prism: IPrismFn;
export default prism;
//# sourceMappingURL=prism.d.ts.map