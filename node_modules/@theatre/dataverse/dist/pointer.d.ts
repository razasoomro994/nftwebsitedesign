import type { $IntentionalAny } from './types';
declare type PathToProp = Array<string | number>;
declare type PointerMeta = {
    root: {};
    path: (string | number)[];
};
export declare type UnindexableTypesForPointer = number | string | boolean | null | void | undefined | Function;
export declare type UnindexablePointer = {
    [K in $IntentionalAny]: Pointer<undefined>;
};
export declare type PointerType<O> = {
    $$__pointer_type: O;
};
export declare type Pointer<O> = PointerType<O> & (O extends UnindexableTypesForPointer ? UnindexablePointer : unknown extends O ? UnindexablePointer : O extends (infer T)[] ? Pointer<T>[] : O extends {} ? {
    [K in keyof O]-?: Pointer<O[K]>;
} : UnindexablePointer);
export declare const getPointerMeta: (p: Pointer<$IntentionalAny> | Pointer<{}> | Pointer<unknown>) => PointerMeta;
export declare const getPointerParts: (p: Pointer<$IntentionalAny> | Pointer<{}> | Pointer<unknown>) => {
    root: {};
    path: PathToProp;
};
declare function pointer<O>({ root, path, }: {
    root: {};
    path: Array<string | number>;
}): Pointer<O>;
export default pointer;
export declare const isPointer: (p: $IntentionalAny) => p is Pointer<unknown>;
//# sourceMappingURL=pointer.d.ts.map