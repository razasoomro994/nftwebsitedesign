import { Pointer, PointerType } from '@theatre/dataverse';

declare type VoidFn = () => void;
declare type SerializableMap<Primitives extends SerializablePrimitive = SerializablePrimitive> = {
    [Key in string]?: SerializableValue<Primitives>;
};
declare type SerializablePrimitive = string | number | boolean;
declare type SerializableValue<Primitives extends SerializablePrimitive = SerializablePrimitive> = Primitives | SerializableMap;
declare type DeepPartialOfSerializableValue<T extends SerializableValue> = T extends SerializableMap ? {
    [K in keyof T]?: DeepPartialOfSerializableValue<Exclude<T[K], undefined>>;
} : T;
/** For `any`s that we don't care about */
declare type $IntentionalAny = any;

/**
 * Represents the address to a project
 */
interface ProjectAddress {
    projectId: string;
}
/**
 * Represents the address to a specific instance of a Sheet
 *
 * @example
 * ```ts
 * const sheet = project.sheet('a sheet', 'some instance id')
 * sheet.address.sheetId === 'a sheet'
 * sheet.address.sheetInstanceId === 'sheetInstanceId'
 * ```
 */
interface SheetAddress extends ProjectAddress {
    sheetId: string;
    sheetInstanceId: string;
}
/**
 * Represents the address to a Sheet's Object
 */
interface SheetObjectAddress extends SheetAddress {
    /**
     * The key of the object.
     *
     * @example
     * ```ts
     * const obj = sheet.object('foo', {})
     * obj.address.objectKey === 'foo'
     * ```
     */
    objectKey: string;
}

/**
 * A compound prop type (basically a JS object).
 *
 * @example
 * Usage:
 * ```ts
 * // shorthand
 * const position = {
 *   x: 0,
 *   y: 0
 * }
 * assert(sheet.object('some object', position).value.x === 0)
 *
 * // nesting
 * const foo = {bar: {baz: {quo: 0}}}
 * assert(sheet.object('some object', foo).bar.baz.quo === 0)
 *
 * // With additional options:
 * const position = t.compound(
 *   {x: 0, y: 0},
 *   // a custom label for the prop:
 *   {label: "Position"}
 * )
 * ```
 *
 */
declare const compound: <Props extends IShorthandCompoundProps>(props: Props, opts?: PropTypeConfigOpts | undefined) => PropTypeConfig_Compound<ShorthandCompoundPropsToLonghandCompoundProps<Props>>;
/**
 * A number prop type.
 *
 * @example
 * Usage
 * ```ts
 * // shorthand:
 * const obj = sheet.object('key', {x: 0})
 *
 * // With options (equal to above)
 * const obj = sheet.object('key', {
 *   x: t.number(0)
 * })
 *
 * // With a range (note that opts.range is just a visual guide, not a validation rule)
 * const x = t.number(0, {range: [0, 10]}) // limited to 0 and 10
 *
 * // With custom nudging
 * const x = t.number(0, {nudgeMultiplier: 0.1}) // nudging will happen in 0.1 increments
 *
 * // With custom nudging function
 * const x = t.number({
 *   nudgeFn: (
 *     // the mouse movement (in pixels)
 *     deltaX: number,
 *     // the movement as a fraction of the width of the number editor's input
 *     deltaFraction: number,
 *     // A multiplier that's usually 1, but might be another number if user wants to nudge slower/faster
 *     magnitude: number,
 *     // the configuration of the number
 *     config: {nudgeMultiplier?: number; range?: [number, number]},
 *   ): number => {
 *     return deltaX * magnitude
 *   },
 * })
 * ```
 *
 * @param defaultValue - The default value (Must be a finite number)
 * @param opts - The options (See usage examples)
 * @returns A number prop config
 */
declare const number: (defaultValue: number, opts?: ({
    nudgeFn?: NumberNudgeFn | undefined;
    range?: PropTypeConfig_Number['range'];
    nudgeMultiplier?: number | undefined;
} & PropTypeConfigOpts) | undefined) => PropTypeConfig_Number;
/**
 * A boolean prop type
 *
 * @example
 * Usage:
 * ```ts
 * // shorthand:
 * const obj = sheet.object('key', {isOn: true})
 *
 * // with a label:
 * const obj = sheet.object('key', {
 *   isOn: t.boolean(true, {
 *     label: 'Enabled'
 *   })
 * })
 * ```
 *
 * @param defaultValue - The default value (must be a boolean)
 * @param opts - Options (See usage examples)
 */
declare const boolean: (defaultValue: boolean, opts?: PropTypeConfigOpts | undefined) => PropTypeConfig_Boolean;
/**
 * A string prop type
 *
 * @example
 * Usage:
 * ```ts
 * // shorthand:
 * const obj = sheet.object('key', {message: "Animation loading"})
 *
 * // with a label:
 * const obj = sheet.object('key', {
 *   message: t.string("Animation Loading", {
 *     label: 'The Message'
 *   })
 * })
 * ```
 *
 * @param defaultValue - The default value (must be a string)
 * @param opts - The options (See usage examples)
 * @returns A string prop type
 */
declare const string: (defaultValue: string, opts?: PropTypeConfigOpts | undefined) => PropTypeConfig_String;
/**
 * A stringLiteral prop type, useful for building menus or radio buttons.
 *
 * @example
 * Usage:
 * ```ts
 * // Basic usage
 * const obj = sheet.object('key', {
 *   light: t.stringLiteral("r", {r: "Red", "g": "Green"})
 * })
 *
 * // Shown as a radio switch with a custom label
 * const obj = sheet.object('key', {
 *   light: t.stringLiteral("r", {r: "Red", "g": "Green"})
 * }, {as: "switch", label: "Street Light"})
 * ```
 *
 * @returns A stringLiteral prop type
 *
 */
declare function stringLiteral<Opts extends {
    [key in string]: string;
}>(
/**
 * Default value (a string that equals one of the options)
 */
defaultValue: Extract<keyof Opts, string>, 
/**
 * The options. Use the `"value": "Label"` format.
 *
 * An object like `{[value]: Label}`. Example: `{r: "Red", "g": "Green"}`
 */
options: Opts, 
/**
 * opts.as Determines if editor is shown as a menu or a switch. Either 'menu' or 'switch'.  Default: 'menu'
 */
opts?: {
    as?: 'menu' | 'switch';
} & PropTypeConfigOpts): PropTypeConfig_StringLiteral<Extract<keyof Opts, string>>;
interface IBasePropType<ValueType> {
    valueType: ValueType;
    [propTypeSymbol]: 'TheatrePropType';
    label: string | undefined;
}
interface PropTypeConfig_Number extends IBasePropType<number> {
    type: 'number';
    default: number;
    range?: [min: number, max: number];
    nudgeFn: NumberNudgeFn;
    nudgeMultiplier: number;
}
declare type NumberNudgeFn = (p: {
    deltaX: number;
    deltaFraction: number;
    magnitude: number;
    config: PropTypeConfig_Number;
}) => number;
interface PropTypeConfig_Boolean extends IBasePropType<boolean> {
    type: 'boolean';
    default: boolean;
}
interface PropTypeConfigOpts {
    label?: string;
}
interface PropTypeConfig_String extends IBasePropType<string> {
    type: 'string';
    default: string;
}
interface PropTypeConfig_StringLiteral<T extends string> extends IBasePropType<T> {
    type: 'stringLiteral';
    default: T;
    options: Record<T, string>;
    as: 'menu' | 'switch';
}
/**
 *
 */
interface PropTypeConfig_Compound<Props extends IValidCompoundProps> extends IBasePropType<{
    [K in keyof Props]: Props[K]['valueType'];
}> {
    type: 'compound';
    props: Record<string, PropTypeConfig>;
}
interface PropTypeConfig_Enum extends IBasePropType<{}> {
    type: 'enum';
    cases: Record<string, PropTypeConfig>;
    defaultCase: string;
}
declare type PropTypeConfig_AllPrimitives = PropTypeConfig_Number | PropTypeConfig_Boolean | PropTypeConfig_String | PropTypeConfig_StringLiteral<$IntentionalAny>;
declare type PropTypeConfig = PropTypeConfig_AllPrimitives | PropTypeConfig_Compound<$IntentionalAny> | PropTypeConfig_Enum;

declare const index_d_compound: typeof compound;
declare const index_d_number: typeof number;
declare const index_d_boolean: typeof boolean;
declare const index_d_string: typeof string;
declare const index_d_stringLiteral: typeof stringLiteral;
type index_d_PropTypeConfig_Number = PropTypeConfig_Number;
type index_d_NumberNudgeFn = NumberNudgeFn;
type index_d_PropTypeConfig_Boolean = PropTypeConfig_Boolean;
type index_d_PropTypeConfigOpts = PropTypeConfigOpts;
type index_d_PropTypeConfig_String = PropTypeConfig_String;
type index_d_PropTypeConfig_StringLiteral<_0> = PropTypeConfig_StringLiteral<_0>;
type index_d_PropTypeConfig_Compound<_0> = PropTypeConfig_Compound<_0>;
type index_d_PropTypeConfig_Enum = PropTypeConfig_Enum;
type index_d_PropTypeConfig_AllPrimitives = PropTypeConfig_AllPrimitives;
type index_d_PropTypeConfig = PropTypeConfig;
declare namespace index_d {
  export {
    index_d_compound as compound,
    index_d_number as number,
    index_d_boolean as boolean,
    index_d_string as string,
    index_d_stringLiteral as stringLiteral,
    index_d_PropTypeConfig_Number as PropTypeConfig_Number,
    index_d_NumberNudgeFn as NumberNudgeFn,
    index_d_PropTypeConfig_Boolean as PropTypeConfig_Boolean,
    index_d_PropTypeConfigOpts as PropTypeConfigOpts,
    index_d_PropTypeConfig_String as PropTypeConfig_String,
    index_d_PropTypeConfig_StringLiteral as PropTypeConfig_StringLiteral,
    index_d_PropTypeConfig_Compound as PropTypeConfig_Compound,
    index_d_PropTypeConfig_Enum as PropTypeConfig_Enum,
    index_d_PropTypeConfig_AllPrimitives as PropTypeConfig_AllPrimitives,
    index_d_PropTypeConfig as PropTypeConfig,
  };
}

declare const propTypeSymbol: unique symbol;
declare type IValidCompoundProps = {
    [K in string]: PropTypeConfig;
};
declare type IShorthandProp = string | number | boolean | PropTypeConfig | IShorthandCompoundProps;
declare type IShorthandCompoundProps = {
    [K in string]: IShorthandProp;
};
declare type ShorthandPropToLonghandProp<P extends IShorthandProp> = P extends string ? PropTypeConfig_String : P extends number ? PropTypeConfig_Number : P extends boolean ? PropTypeConfig_Boolean : P extends PropTypeConfig ? P : P extends IShorthandCompoundProps ? PropTypeConfig_Compound<ShorthandCompoundPropsToLonghandCompoundProps<P>> : never;
declare type ShorthandCompoundPropsToLonghandCompoundProps<P extends IShorthandCompoundProps> = {
    [K in keyof P]: ShorthandPropToLonghandProp<P[K]>;
};

interface ISheetObject<Props extends IShorthandCompoundProps = {}> {
    /**
     * All Objects will have `object.type === 'Theatre_SheetObject_PublicAPI'`
     */
    readonly type: 'Theatre_SheetObject_PublicAPI';
    /**
     * The current values of the props.
     *
     * @example
     * Usage:
     * ```ts
     * const obj = sheet.object("obj", {x: 0})
     * console.log(obj.value.x) // prints 0 or the current numeric value
     * ```
     */
    readonly value: ShorthandPropToLonghandProp<Props>['valueType'];
    /**
     * A Pointer to the props of the object.
     *
     * More documentation soon.
     */
    readonly props: Pointer<this['value']>;
    /**
     * The instance of Sheet the Object belongs to
     */
    readonly sheet: ISheet;
    /**
     * The Project the project belongs to
     */
    readonly project: IProject;
    /**
     * An object representing the address of the Object
     */
    readonly address: SheetObjectAddress;
    /**
     * Calls `fn` every time the value of the props change.
     *
     * @returns an Unsubscribe function
     *
     * @example
     * Usage:
     * ```ts
     * const obj = sheet.object("Box", {position: {x: 0, y: 0}})
     * const div = document.getElementById("box")
     *
     * const unsubscribe = obj.onValuesChange((newValues) => {
     *   div.style.left = newValues.position.x + 'px'
     *   div.style.top = newValues.position.y + 'px'
     * })
     *
     * // you can call unsubscribe() to stop listening to changes
     * ```
     */
    onValuesChange(fn: (values: this['value']) => void): VoidFn;
    /**
     * Sets the initial value of the object. This value overrides the default
     * values defined in the prop types, but would itself be overridden if the user
     * overrides it in the UI with a static or animated value.
     *
     * @example
     * Usage:
     * ```ts
     * const obj = sheet.object("obj", {position: {x: 0, y: 0}})
     *
     * obj.value // {position: {x: 0, y: 0}}
     *
     * // here, we only override position.x
     * obj.initialValue = {position: {x: 2}}
     *
     * obj.value // {position: {x: 2, y: 0}}
     * ```
     */
    set initialValue(value: DeepPartialOfSerializableValue<this['value']>);
}

declare type IPlaybackRange = [from: number, to: number];
declare type IPlaybackDirection = 'normal' | 'reverse' | 'alternate' | 'alternateReverse';

interface IAttachAudioArgs {
    /**
     * Either a URL to the audio file (eg "https://localhost/audio.mp3") or an instance of AudioBuffer
     */
    source: string | AudioBuffer;
    /**
     * An optional AudioContext. If not provided, one will be created.
     */
    audioContext?: AudioContext;
    /**
     * An AudioNode to feed the audio into. Will use audioContext.destination if not provided.
     */
    destinationNode?: AudioNode;
}
interface ISequence {
    readonly type: 'Theatre_Sequence_PublicAPI';
    /**
     * Starts playback of a sequence.
     * Returns a promise that either resolves to true when the playback completes,
     * or resolves to false if playback gets interrupted (for example by calling sequence.pause())
     *
     * @returns A promise that resolves when the playback is finished, or rejects if interruped
     *
     * @example
     * Usage:
     * ```ts
     * // plays the sequence from the current position to sequence.length
     * sheet.sequence.play()
     *
     * // plays the sequence at 2.4x speed
     * sheet.sequence.play({rate: 2.4})
     *
     * // plays the sequence from second 1 to 4
     * sheet.sequence.play({range: [1, 4]})
     *
     * // plays the sequence 4 times
     * sheet.sequence.play({iterationCount: 4})
     *
     * // plays the sequence in reverse
     * sheet.sequence.play({direction: 'reverse'})
     *
     * // plays the sequence back and forth forever (until interrupted)
     * sheet.sequence.play({iterationCount: Infinity, direction: 'alternateReverse})
     *
     * // plays the sequence and logs "done" once playback is finished
     * sheet.sequence.play().then(() => console.log('done'))
     * ```
     */
    play(conf?: {
        /**
         * The number of times the animation must run. Must be an integer larger
         * than 0. Defaults to 1. Pick Infinity to run forever
         */
        iterationCount?: number;
        /**
         * Limits the range to be played. Default is [0, sequence.length]
         */
        range?: IPlaybackRange;
        /**
         * The playback rate. Defaults to 1. Choosing 2 would play the animation
         * at twice the speed.
         */
        rate?: number;
        /**
         * The direction of the playback. Similar to CSS's animation-direction
         */
        direction?: IPlaybackDirection;
    }): Promise<boolean>;
    /**
     * Pauses the currently playing animation
     */
    pause(): void;
    /**
     * The current position of the playhead.
     * In a time-based sequence, this represents the current time in seconds.
     */
    position: number;
    /**
     * A Pointer to the sequence's inner state.
     *
     * @remarks
     * As with any Pointer, you can use this with {@link onChange | onChange()} to listen to its value changes
     * or with {@link val | val()} to read its current value.
     *
     * @example Usage
     * ```ts
     * import {onChange, val} from '@theatre/core'
     *
     * // let's assume `sheet` is a sheet
     * const sequence = sheet.sequence
     *
     * onChange(sequence.pointer.length, (len) => {
     *   console.log("Length of the sequence changed to:", len)
     * })
     *
     * onChange(sequence.pointer.position, (position) => {
     *   console.log("Position of the sequence changed to:", position)
     * })
     *
     * onChange(sequence.pointer.playing, (playing) => {
     *   console.log(playing ? 'playing' : 'paused')
     * })
     *
     * // we can also read the current value of the pointer
     * console.log('current length is', val(sequence.pointer.length))
     * ```
     */
    pointer: Pointer<{
        playing: boolean;
        length: number;
        position: number;
    }>;
    /**
     * Attaches an audio source to the sequence. Playing the sequence automatically
     * plays the audio source and their times are kept in sync.
     *
     * @returns A promise that resolves once the audio source is loaded and decoded
     *
     * Learn more [here](https://docs.theatrejs.com/in-depth/#sequence-attachaudio).
     *
     * @example
     * Usage:
     * ```ts
     * // Loads and decodes audio from the URL and then attaches it to the sequence
     * await sheet.sequence.attachAudio({source: "https://localhost/audio.ogg"})
     * sheet.sequence.play()
     *
     * // Providing your own AudioAPI Context, destination, etc
     * const audioContext: AudioContext = {...} // create an AudioContext using the Audio API
     * const audioBuffer: AudioBuffer = {...} // create an AudioBuffer
     * const destinationNode = audioContext.destination
     *
     * await sheet.sequence.attachAudio({source: audioBuffer, audioContext, destinationNode})
     * ```
     *
     * Note: It's better to provide the `audioContext` rather than allow Theatre to create it.
     * That's because some browsers [suspend the audioContext](https://developer.chrome.com/blog/autoplay/#webaudio)
     * unless it's initiated by a user gesture, like a click. If that happens, Theatre will
     * wait for a user gesture to resume the audioContext. But that's probably not an
     * optimal user experience. It is better to provide a button or some other UI element
     * to communicate to the user that they have to initiate the animation.
     *
     * @example
     * Example:
     * ```ts
     * // html: <button id="#start">start</button>
     * const button = document.getElementById('start')
     *
     * button.addEventListener('click', async () => {
     *   const audioContext = ...
     *   await sheet.sequence.attachAudio({audioContext, source: '...'})
     *   sheet.sequence.play()
     * })
     * ```
     */
    attachAudio(args: IAttachAudioArgs): Promise<{
        /**
         * An {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer | AudioBuffer}.
         * If `args.source` is a URL, then `decodedBuffer` would be the result
         * of {@link https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/decodeAudioData | audioContext.decodeAudioData()}
         * on the audio file at that URL.
         *
         * If `args.source` is an `AudioBuffer`, then `decodedBuffer` would be equal to `args.source`
         */
        decodedBuffer: AudioBuffer;
        /**
         * The `AudioContext`. It is either equal to `source.audioContext` if it is provided, or
         * one that's created on the fly.
         */
        audioContext: AudioContext;
        /**
         * Equals to either `args.destinationNode`, or if none is provided, it equals `audioContext.destinationNode`.
         *
         * See `gainNode` for more info.
         */
        destinationNode: AudioNode;
        /**
         * This is an intermediate GainNode that Theatre feeds its audio to. It is by default
         * connected to destinationNode, but you can disconnect the gainNode and feed it to your own graph.
         *
         * @example
         * For example:
         * ```ts
         * const {gainNode, audioContext} = await sequence.attachAudio({source: '/audio.mp3'})
         * // disconnect the gainNode (at this point, the sequence's audio track won't be audible)
         * gainNode.disconnect()
         * // create our own gain node
         * const lowerGain = audioContext.createGain()
         * // lower its volume to 10%
         * lowerGain.gain.setValueAtTime(0.1, audioContext.currentTime)
         * // feed the sequence's audio to our lowered gainNode
         * gainNode.connect(lowerGain)
         * // feed the lowered gainNode to the audioContext's destination
         * lowerGain.connect(audioContext.destination)
         * // now audio will be audible, with 10% the volume
         * ```
         */
        gainNode: GainNode;
    }>;
}

interface ISheet {
    /**
     * All sheets have `sheet.type === 'Theatre_Sheet_PublicAPI'`
     */
    readonly type: 'Theatre_Sheet_PublicAPI';
    /**
     * The Project this Sheet belongs to
     */
    readonly project: IProject;
    /**
     * The address of the Sheet
     */
    readonly address: SheetAddress;
    /**
     * Creates a child object for the sheet
     *
     * **Docs: https://docs.theatrejs.com/in-depth/#objects**
     *
     * @param key - Each object is identified by a key, which is a non-empty string
     * @param props - The props of the object. See examples
     *
     * @returns An Object
     *
     * @example
     * Usage:
     * ```ts
     * // Create an object named "a unique key" with no props
     * const obj = sheet.object("a unique key", {})
     * obj.address.objectKey // "a unique key"
     *
     *
     * // Create an object with {x: 0}
     * const obj = sheet.object("obj", {x: 0})
     * obj.value.x // returns 0 or the current number that the user has set
     *
     * // Create an object with nested props
     * const obj = sheet.object("obj", {position: {x: 0, y: 0}})
     * obj.value.position // {x: 0, y: 0}
     * ```
     */
    object<Props extends IShorthandCompoundProps>(key: string, props: Props): ISheetObject<Props>;
    /**
     * The Sequence of this Sheet
     */
    readonly sequence: ISequence;
}

/**
 * A project's config object (currently the only point of configuration is the project's state)
 */
declare type IProjectConfig = {
    /**
     * The state of the project, as [exported](https://docs.theatrejs.com/in-depth/#exporting) by the studio.
     */
    state?: $IntentionalAny;
};
/**
 * A Theatre project
 */
interface IProject {
    readonly type: 'Theatre_Project_PublicAPI';
    /**
     * If `@theatre/studio` is used, this promise would resolve when studio has loaded
     * the state of the project into memory.
     *
     * If `@theatre/studio` is not used, this promise is already resolved.
     */
    readonly ready: Promise<void>;
    /**
     * Shows whether the project is ready to be used.
     * Better to use {@link IProject.ready}, which is a promise that would
     * resolve when the project is ready.
     */
    readonly isReady: boolean;
    /**
     * The project's address
     */
    readonly address: ProjectAddress;
    /**
     * Creates a Sheet under the project
     * @param sheetId - Sheets are identified by their `sheetId`, which must be a string longer than 3 characters
     * @param instanceId - Optionally provide an `instanceId` if you want to create multiple instances of the same Sheet
     * @returns The newly created Sheet
     *
     * **Docs: https://docs.theatrejs.com/in-depth/#sheets**
     */
    sheet(sheetId: string, instanceId?: string): ISheet;
}

/**
 * Returns a project of the given id, or creates one if it doesn't already exist.
 *
 * @remarks
 * If \@theatre/studio is also loaded, then the state of the project will be managed by the studio.
 *
 * [Learn more about exporting](https://docs.theatrejs.com/in-depth/#exporting)
 *
 * @example
 * Usage:
 * ```ts
 * import {getProject} from '@theatre/core'
 * const config = {} // the config can be empty when starting a new project
 * const project = getProject("a-unique-id", config)
 * ```
 *
 * @example
 * Usage with an explicit state:
 * ```ts
 * import {getProject} from '@theatre/core'
 * import state from './saved-state.json'
 * const config = {state} // here the config contains our saved state
 * const project = getProject("a-unique-id", config)
 * ```
 */
declare function getProject(id: string, config?: IProjectConfig): IProject;
/**
 * Calls `callback` every time the pointed value of `pointer` changes.
 *
 * @param pointer - A Pointer (like `object.props.x`)
 * @param callback - The callback is called every time the value of pointer changes
 * @returns An unsubscribe function
 *
 * @example
 * Usage:
 * ```ts
 * import {getProject, onChange} from '@theatre/core'
 *
 * const obj = getProject("A project").sheet("Scene").object("Box", {position: {x: 0}})
 *
 * const usubscribe = onChange(obj.props.position.x, (x) => {
 *   console.log('position.x changed to:', x)
 * })
 *
 * setTimeout(usubscribe, 10000) // stop listening to changes after 10 seconds
 * ```
 */
declare function onChange<P extends PointerType<$IntentionalAny>>(pointer: P, callback: (value: P extends PointerType<infer T> ? T : unknown) => void): VoidFn;
/**
 * Takes a Pointer and returns the value it points to.
 *
 * @param pointer - A pointer (like `object.props.x`)
 * @returns The value the pointer points to
 *
 * @example
 *
 * Usage
 * ```ts
 * import {val, getProject} from '@theatre/core'
 *
 * const obj = getProject("A project").sheet("Scene").object("Box", {position: {x: 0}})
 *
 * console.log(val(obj.props.position.x)) // logs the value of obj.props.x
 * ```
 */
declare function val<T>(pointer: PointerType<T>): T;

export { IProject, IProjectConfig, ISequence, ISheet, ISheetObject, getProject, onChange, index_d as types, val };
