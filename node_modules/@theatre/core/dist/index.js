var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../node_modules/timing-function/lib/UnitBezier.js
var require_UnitBezier = __commonJS({
  "../node_modules/timing-function/lib/UnitBezier.js"(exports, module2) {
    var UnitBezier2;
    module2.exports = UnitBezier2 = function() {
      function UnitBezier3(p1x, p1y, p2x, p2y) {
        this.set(p1x, p1y, p2x, p2y);
      }
      UnitBezier3.prototype.set = function(p1x, p1y, p2x, p2y) {
        this._cx = 3 * p1x;
        this._bx = 3 * (p2x - p1x) - this._cx;
        this._ax = 1 - this._cx - this._bx;
        this._cy = 3 * p1y;
        this._by = 3 * (p2y - p1y) - this._cy;
        this._ay = 1 - this._cy - this._by;
      };
      UnitBezier3.epsilon = 1e-6;
      UnitBezier3.prototype._sampleCurveX = function(t3) {
        return ((this._ax * t3 + this._bx) * t3 + this._cx) * t3;
      };
      UnitBezier3.prototype._sampleCurveY = function(t3) {
        return ((this._ay * t3 + this._by) * t3 + this._cy) * t3;
      };
      UnitBezier3.prototype._sampleCurveDerivativeX = function(t3) {
        return (3 * this._ax * t3 + 2 * this._bx) * t3 + this._cx;
      };
      UnitBezier3.prototype._solveCurveX = function(x2, epsilon) {
        var d2, i2, t0, t1, t22, x22;
        t0 = void 0;
        t1 = void 0;
        t22 = void 0;
        x22 = void 0;
        d2 = void 0;
        i2 = void 0;
        t22 = x2;
        i2 = 0;
        while (i2 < 8) {
          x22 = this._sampleCurveX(t22) - x2;
          if (Math.abs(x22) < epsilon) {
            return t22;
          }
          d2 = this._sampleCurveDerivativeX(t22);
          if (Math.abs(d2) < epsilon) {
            break;
          }
          t22 = t22 - x22 / d2;
          i2++;
        }
        t0 = 0;
        t1 = 1;
        t22 = x2;
        if (t22 < t0) {
          return t0;
        }
        if (t22 > t1) {
          return t1;
        }
        while (t0 < t1) {
          x22 = this._sampleCurveX(t22);
          if (Math.abs(x22 - x2) < epsilon) {
            return t22;
          }
          if (x2 > x22) {
            t0 = t22;
          } else {
            t1 = t22;
          }
          t22 = (t1 - t0) * 0.5 + t0;
        }
        return t22;
      };
      UnitBezier3.prototype.solve = function(x2, epsilon) {
        return this._sampleCurveY(this._solveCurveX(x2, epsilon));
      };
      UnitBezier3.prototype.solveSimple = function(x2) {
        return this._sampleCurveY(this._solveCurveX(x2, 1e-6));
      };
      return UnitBezier3;
    }();
  }
});

// ../node_modules/levenshtein-edit-distance/index.js
var require_levenshtein_edit_distance = __commonJS({
  "../node_modules/levenshtein-edit-distance/index.js"(exports, module2) {
    var cache;
    var codes;
    cache = [];
    codes = [];
    function levenshtein(value, other, insensitive) {
      var length, lengthOther, code, result, distance, distanceOther, index, indexOther;
      if (value === other) {
        return 0;
      }
      length = value.length;
      lengthOther = other.length;
      if (length === 0) {
        return lengthOther;
      }
      if (lengthOther === 0) {
        return length;
      }
      if (insensitive) {
        value = value.toLowerCase();
        other = other.toLowerCase();
      }
      index = 0;
      while (index < length) {
        codes[index] = value.charCodeAt(index);
        cache[index] = ++index;
      }
      indexOther = 0;
      while (indexOther < lengthOther) {
        code = other.charCodeAt(indexOther);
        result = distance = indexOther++;
        index = -1;
        while (++index < length) {
          distanceOther = code === codes[index] ? distance : distance + 1;
          distance = cache[index];
          cache[index] = result = distance > result ? distanceOther > result ? result + 1 : distanceOther : distanceOther > distance ? distance + 1 : distanceOther;
        }
      }
      return result;
    }
    module2.exports = levenshtein;
  }
});

// ../node_modules/propose/propose.js
var require_propose = __commonJS({
  "../node_modules/propose/propose.js"(exports, module2) {
    var levenshtein = require_levenshtein_edit_distance();
    function propose2() {
      var ratio;
      var distance;
      var proposed;
      var threshold;
      var ignoreCase;
      var max_ratio = 0;
      var word = arguments[0];
      var dictionary = arguments[1];
      var len = dictionary.length;
      var options = arguments[2];
      if (options) {
        threshold = options.threshold;
        ignoreCase = options.ignoreCase;
      }
      if (threshold === void 0)
        threshold = 0;
      for (var i2 = 0; i2 < len; ++i2) {
        if (ignoreCase)
          distance = levenshtein(word, dictionary[i2], true);
        else
          distance = levenshtein(word, dictionary[i2]);
        if (distance > word.length)
          ratio = 1 - distance / dictionary[i2].length;
        else
          ratio = 1 - distance / word.length;
        if (ratio > max_ratio) {
          max_ratio = ratio;
          proposed = dictionary[i2];
        }
      }
      if (max_ratio >= threshold)
        return proposed;
      return null;
    }
    module2.exports = propose2;
  }
});

// ../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../node_modules/fast-deep-equal/index.js"(exports, module2) {
    "use strict";
    module2.exports = function equal(a2, b2) {
      if (a2 === b2)
        return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor)
          return false;
        var length, i2, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b2.length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal(a2[i2], b2[i2]))
              return false;
          return true;
        }
        if (a2.constructor === RegExp)
          return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf)
          return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString)
          return a2.toString() === b2.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b2).length)
          return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i2]))
            return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys[i2];
          if (!equal(a2[key], b2[key]))
            return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// core/src/index.ts
__export(exports, {
  getProject: () => getProject,
  onChange: () => onChange,
  types: () => propTypes_exports,
  val: () => val6
});

// core/src/coreExports.ts
var coreExports_exports = {};
__export(coreExports_exports, {
  getProject: () => getProject,
  onChange: () => onChange,
  types: () => propTypes_exports,
  val: () => val6
});

// core/src/projects/projectsSingleton.ts
var import_dataverse = __toModule(require("@theatre/dataverse"));
var ProjectsSingleton = class {
  constructor() {
    __publicField(this, "atom", new import_dataverse.Atom({ projects: {} }));
  }
  add(id, project) {
    this.atom.reduceState(["projects", id], () => project);
  }
  get(id) {
    return this.atom.getState().projects[id];
  }
  has(id) {
    return !!this.get(id);
  }
};
var singleton = new ProjectsSingleton();
var projectsSingleton_default = singleton;

// core/src/privateAPIs.ts
var publicAPIToPrivateAPIMap = new WeakMap();
function privateAPI(pub) {
  return publicAPIToPrivateAPIMap.get(pub);
}
function setPrivateAPI(pub, priv) {
  publicAPIToPrivateAPIMap.set(pub, priv);
}

// shared/src/utils/index.ts
var emptyArray = [];

// ../node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// ../node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
var freeGlobal_default = freeGlobal;

// ../node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// ../node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// ../node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// ../node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// ../node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// ../node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// ../node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// ../node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// ../node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// ../node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// ../node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// ../node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// ../node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var toSource_default = toSource;

// ../node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// ../node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// ../node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// ../node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// ../node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// ../node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// ../node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// ../node_modules/lodash-es/_hashHas.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var hashHas_default = hashHas;

// ../node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// ../node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// ../node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// ../node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// ../node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// ../node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// ../node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// ../node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// ../node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// ../node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// ../node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// ../node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// ../node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// ../node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// ../node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// ../node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// ../node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// ../node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// ../node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// ../node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// ../node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// ../node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// ../node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default = arrayMap;

// ../node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// ../node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// ../node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// ../node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;

// ../node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// ../node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// shared/src/utils/getDeep.ts
function getDeep(v2, path) {
  if (path.length === 0)
    return v2;
  return get_default(v2, path);
}

// shared/src/utils/SimpleCache.ts
var SimpleCache = class {
  constructor() {
    __publicField(this, "_values", {});
  }
  get(key, producer) {
    if (this.has(key)) {
      return this._values[key];
    } else {
      const cachedValue = producer();
      this._values[key] = cachedValue;
      return cachedValue;
    }
  }
  has(key) {
    return this._values.hasOwnProperty(key);
  }
};

// core/src/sheetObjects/SheetObjectTemplate.ts
var import_dataverse7 = __toModule(require("@theatre/dataverse"));

// ../node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var defineProperty_default = defineProperty;

// ../node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// ../node_modules/lodash-es/_assignValue.js
var objectProto6 = Object.prototype;
var hasOwnProperty5 = objectProto6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty5.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// ../node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// ../node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey_default(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// ../node_modules/lodash-es/set.js
function set(object, path, value) {
  return object == null ? object : baseSet_default(object, path, value);
}
var set_default = set;

// core/src/sheetObjects/getPropDefaultsOfSheetObject.ts
var cachedDefaults = new WeakMap();
function getPropDefaultsOfSheetObject(config) {
  return getDefaultsOfPropTypeConfig(config);
}
function getDefaultsOfPropTypeConfig(config) {
  if (cachedDefaults.has(config)) {
    return cachedDefaults.get(config);
  }
  const generated = config.type === "compound" ? generateDefaultsForCompound(config) : config.type === "enum" ? generateDefaultsForEnum(config) : config.default;
  cachedDefaults.set(config, generated);
  return generated;
}
function generateDefaultsForEnum(config) {
  const defaults = {
    $case: config.defaultCase
  };
  for (const [case_, caseConf] of Object.entries(config.cases)) {
    defaults[case_] = getDefaultsOfPropTypeConfig(caseConf);
  }
  return defaults;
}
function generateDefaultsForCompound(config) {
  const defaults = {};
  for (const [key, propConf] of Object.entries(config.props)) {
    defaults[key] = getDefaultsOfPropTypeConfig(propConf);
  }
  return defaults;
}

// core/src/sequences/trackValueAtTime.ts
var import_dataverse2 = __toModule(require("@theatre/dataverse"));

// shared/src/logger.ts
var logger = {
  log: console.log,
  warn: console.warn,
  error: console.error,
  trace: console.trace
};
var logger_default = logger;

// core/src/sequences/trackValueAtTime.ts
var import_UnitBezier = __toModule(require_UnitBezier());
function trackValueAtTime(trackP, timeD) {
  return (0, import_dataverse2.prism)(() => {
    const track = (0, import_dataverse2.val)(trackP);
    const driverD = import_dataverse2.prism.memo("driver", () => {
      if (!track) {
        return new import_dataverse2.ConstantDerivation(void 0);
      } else if (track.type === "BasicKeyframedTrack") {
        return trackValueAtTime_basicKeyframedTrack(track, timeD);
      } else {
        logger_default.error(`Track type not yet supported.`);
        return new import_dataverse2.ConstantDerivation(void 0);
      }
    }, [track]);
    return driverD.getValue();
  });
}
function trackValueAtTime_basicKeyframedTrack(track, timeD) {
  return (0, import_dataverse2.prism)(() => {
    let stateRef = import_dataverse2.prism.ref("state", { started: false });
    let state = stateRef.current;
    const time = timeD.getValue();
    if (!state.started || time < state.validFrom || state.validTo <= time) {
      stateRef.current = state = pp(timeD, track);
    }
    return state.der.getValue();
  });
}
var undefinedConstD = new import_dataverse2.ConstantDerivation(void 0);
var pp = (progressionD, track) => {
  const progression = progressionD.getValue();
  if (track.keyframes.length === 0) {
    return {
      started: true,
      validFrom: -Infinity,
      validTo: Infinity,
      der: undefinedConstD
    };
  }
  let currentKeyframeIndex = 0;
  while (true) {
    const currentKeyframe = track.keyframes[currentKeyframeIndex];
    if (!currentKeyframe) {
      if (process.env.NODE_ENV !== "production") {
        logger_default.error(`Bug here`);
      }
      return states.error;
    }
    const isLastKeyframe = currentKeyframeIndex === track.keyframes.length - 1;
    if (progression < currentKeyframe.position) {
      if (currentKeyframeIndex === 0) {
        return states.beforeFirstKeyframe(currentKeyframe);
      } else {
        if (process.env.NODE_ENV !== "production") {
          logger_default.error(`Bug here`);
        }
        return states.error;
      }
    } else if (currentKeyframe.position === progression) {
      if (isLastKeyframe) {
        return states.lastKeyframe(currentKeyframe);
      } else {
        return states.between(currentKeyframe, track.keyframes[currentKeyframeIndex + 1], progressionD);
      }
    } else {
      if (currentKeyframeIndex === track.keyframes.length - 1) {
        return states.lastKeyframe(currentKeyframe);
      } else {
        const nextKeyframeIndex = currentKeyframeIndex + 1;
        if (track.keyframes[nextKeyframeIndex].position <= progression) {
          currentKeyframeIndex = nextKeyframeIndex;
          continue;
        } else {
          return states.between(currentKeyframe, track.keyframes[currentKeyframeIndex + 1], progressionD);
        }
      }
    }
  }
};
var states = {
  beforeFirstKeyframe(kf) {
    return {
      started: true,
      validFrom: -Infinity,
      validTo: kf.position,
      der: new import_dataverse2.ConstantDerivation(kf.value)
    };
  },
  lastKeyframe(kf) {
    return {
      started: true,
      validFrom: kf.position,
      validTo: Infinity,
      der: new import_dataverse2.ConstantDerivation(kf.value)
    };
  },
  between(left, right, progressionD) {
    if (!left.connectedRight) {
      return {
        started: true,
        validFrom: left.position,
        validTo: right.position,
        der: new import_dataverse2.ConstantDerivation(left.value)
      };
    }
    const solver = new import_UnitBezier.default(left.handles[2], left.handles[3], right.handles[0], right.handles[1]);
    const globalProgressionToLocalProgression = (globalProgression) => {
      return (globalProgression - left.position) / (right.position - left.position);
    };
    const der = (0, import_dataverse2.prism)(() => {
      const progression = globalProgressionToLocalProgression(progressionD.getValue());
      const valueProgression = solver.solveSimple(progression);
      return left.value + valueProgression * (right.value - left.value);
    });
    return {
      started: true,
      validFrom: left.position,
      validTo: right.position,
      der
    };
  },
  error: {
    started: true,
    validFrom: -Infinity,
    validTo: Infinity,
    der: undefinedConstD
  }
};

// shared/src/utils/deepMergeWithCache.ts
function deepMergeWithCache(base, override, cache) {
  const _cache = cache;
  const possibleCachedValue = _cache.get(base);
  if (possibleCachedValue && possibleCachedValue.override === override) {
    return possibleCachedValue.merged;
  }
  const merged = __spreadValues({}, base);
  for (const key of Object.keys(override)) {
    const valueInOverride = override[key];
    const valueInBase = base[key];
    merged[key] = typeof valueInOverride === "object" && typeof valueInBase === "object" ? deepMergeWithCache(valueInBase, valueInOverride, cache) : typeof valueInOverride === "undefined" ? valueInBase : valueInOverride;
  }
  cache.set(base, { override, merged });
  return merged;
}

// shared/src/utils/pointerDeep.ts
function pointerDeep(base, toAppend) {
  let p2 = base;
  for (const k2 of toAppend) {
    p2 = p2[k2];
  }
  return p2;
}

// shared/src/utils/valToAtom.ts
var import_dataverse3 = __toModule(require("@theatre/dataverse"));
var valToAtom = (key, vals) => {
  const a2 = import_dataverse3.prism.memo(key, () => new import_dataverse3.Atom(vals), []);
  a2.setState(vals);
  return a2;
};

// core/src/sheetObjects/SheetObject.ts
var import_dataverse6 = __toModule(require("@theatre/dataverse"));

// core/src/coreTicker.ts
var import_dataverse4 = __toModule(require("@theatre/dataverse"));
var coreTicker = new import_dataverse4.Ticker();
var coreTicker_default = coreTicker;
var onAnimationFrame = (t3) => {
  coreTicker.tick(t3);
  window.requestAnimationFrame(onAnimationFrame);
};
window.requestAnimationFrame(onAnimationFrame);

// core/src/sheetObjects/TheatreSheetObject.ts
var import_dataverse5 = __toModule(require("@theatre/dataverse"));
var TheatreSheetObject = class {
  constructor(internals) {
    __publicField(this, "_cache", new SimpleCache());
    setPrivateAPI(this, internals);
  }
  get type() {
    return "Theatre_SheetObject_PublicAPI";
  }
  get props() {
    return privateAPI(this).propsP;
  }
  get sheet() {
    return privateAPI(this).sheet.publicApi;
  }
  get project() {
    return privateAPI(this).sheet.project.publicApi;
  }
  get address() {
    return __spreadValues({}, privateAPI(this).address);
  }
  _valuesDerivation() {
    return this._cache.get("onValuesChangeDerivation", () => {
      const sheetObject = privateAPI(this);
      const d2 = (0, import_dataverse5.prism)(() => {
        return (0, import_dataverse5.val)(sheetObject.getValues().getValue());
      });
      return d2;
    });
  }
  onValuesChange(fn2) {
    return this._valuesDerivation().tapImmediate(coreTicker_default, fn2);
  }
  get value() {
    return this._valuesDerivation().getValue();
  }
  set initialValue(val7) {
    privateAPI(this).setInitialValue(val7);
  }
};

// core/src/sheetObjects/SheetObject.ts
var SheetObject = class {
  constructor(sheet, template, nativeObject) {
    this.sheet = sheet;
    this.template = template;
    this.nativeObject = nativeObject;
    __publicField(this, "$$isIdentityDerivationProvider", true);
    __publicField(this, "address");
    __publicField(this, "publicApi");
    __publicField(this, "_initialValue", new import_dataverse6.Atom({}));
    __publicField(this, "_cache", new SimpleCache());
    this.address = __spreadProps(__spreadValues({}, template.address), {
      sheetInstanceId: sheet.address.sheetInstanceId
    });
    this.publicApi = new TheatreSheetObject(this);
  }
  get type() {
    return "Theatre_SheetObject";
  }
  getValues() {
    return this._cache.get("getValues()", () => (0, import_dataverse6.prism)(() => {
      const defaults = (0, import_dataverse6.val)(this.template.getDefaultValues());
      const initial = (0, import_dataverse6.val)(this._initialValue.pointer);
      const withInitialCache = import_dataverse6.prism.memo("withInitialCache", () => new WeakMap(), []);
      const withInitial = deepMergeWithCache(defaults, initial, withInitialCache);
      const statics = (0, import_dataverse6.val)(this.template.getStaticValues());
      const withStaticsCache = import_dataverse6.prism.memo("withStatics", () => new WeakMap(), []);
      const withStatics = deepMergeWithCache(withInitial, statics, withStaticsCache);
      let final = withStatics;
      let sequenced;
      {
        const pointerToSequencedValuesD = import_dataverse6.prism.memo("seq", () => this.getSequencedValues(), []);
        const withSeqsCache = import_dataverse6.prism.memo("withSeqsCache", () => new WeakMap(), []);
        sequenced = (0, import_dataverse6.val)((0, import_dataverse6.val)(pointerToSequencedValuesD));
        const withSeqs = deepMergeWithCache(final, sequenced, withSeqsCache);
        final = withSeqs;
      }
      const a2 = valToAtom("finalAtom", final);
      return a2.pointer;
    }));
  }
  getValueByPointer(pointer3) {
    const allValuesP = (0, import_dataverse6.val)(this.getValues());
    const { path } = (0, import_dataverse6.getPointerParts)(pointer3);
    return (0, import_dataverse6.val)(pointerDeep(allValuesP, path));
  }
  getIdentityDerivation(path) {
    return (0, import_dataverse6.prism)(() => {
      const allValuesP = (0, import_dataverse6.val)(this.getValues());
      return (0, import_dataverse6.val)(pointerDeep(allValuesP, path));
    });
  }
  getSequencedValues() {
    return (0, import_dataverse6.prism)(() => {
      const tracksToProcessD = import_dataverse6.prism.memo("tracksToProcess", () => this.template.getArrayOfValidSequenceTracks(), []);
      const tracksToProcess = (0, import_dataverse6.val)(tracksToProcessD);
      const valsAtom = new import_dataverse6.Atom({});
      import_dataverse6.prism.effect("processTracks", () => {
        const untaps = [];
        for (const { trackId, pathToProp } of tracksToProcess) {
          const derivation = this._trackIdToDerivation(trackId);
          const updateSequenceValueFromItsDerivation = () => {
            valsAtom.setIn(pathToProp, derivation.getValue());
          };
          const untap = derivation.changesWithoutValues().tap(updateSequenceValueFromItsDerivation);
          updateSequenceValueFromItsDerivation();
          untaps.push(untap);
        }
        return () => {
          for (const untap of untaps) {
            untap();
          }
        };
      }, tracksToProcess);
      return valsAtom.pointer;
    });
  }
  _trackIdToDerivation(trackId) {
    const trackP = this.template.project.pointers.historic.sheetsById[this.address.sheetId].sequence.tracksByObject[this.address.objectKey].trackData[trackId];
    const timeD = this.sheet.getSequence().positionDerivation;
    return trackValueAtTime(trackP, timeD);
  }
  get propsP() {
    return this._cache.get("propsP", () => (0, import_dataverse6.pointer)({ root: this, path: [] }));
  }
  validateValue(pointer3, value) {
  }
  setInitialValue(val7) {
    this.validateValue(this.propsP, val7);
    this._initialValue.setState(val7);
  }
};

// core/src/sheetObjects/SheetObjectTemplate.ts
var SheetObjectTemplate = class {
  constructor(sheetTemplate, objectKey, nativeObject, config) {
    this.sheetTemplate = sheetTemplate;
    __publicField(this, "address");
    __publicField(this, "type", "Theatre_SheetObjectTemplate");
    __publicField(this, "_config");
    __publicField(this, "_cache", new SimpleCache());
    __publicField(this, "project");
    this.address = __spreadProps(__spreadValues({}, sheetTemplate.address), { objectKey });
    this._config = new import_dataverse7.Atom(config);
    this.project = sheetTemplate.project;
  }
  get config() {
    return this._config.getState();
  }
  createInstance(sheet, nativeObject, config) {
    this._config.setState(config);
    return new SheetObject(sheet, this, nativeObject);
  }
  overrideConfig(config) {
    this._config.setState(config);
  }
  getDefaultValues() {
    return this._cache.get("getDefaultValues()", () => (0, import_dataverse7.prism)(() => {
      const config = (0, import_dataverse7.val)(this._config.pointer);
      return getPropDefaultsOfSheetObject(config);
    }));
  }
  getStaticValues() {
    return this._cache.get("getDerivationOfStatics", () => (0, import_dataverse7.prism)(() => {
      const pointerToSheetState = this.sheetTemplate.project.pointers.historic.sheetsById[this.address.sheetId];
      return (0, import_dataverse7.val)(pointerToSheetState.staticOverrides.byObject[this.address.objectKey]) || {};
    }));
  }
  getArrayOfValidSequenceTracks() {
    return this._cache.get("getArrayOfValidSequenceTracks", () => (0, import_dataverse7.prism)(() => {
      const defaults = (0, import_dataverse7.val)(this.getDefaultValues());
      const pointerToSheetState = this.project.pointers.historic.sheetsById[this.address.sheetId];
      const trackIdByPropPath = (0, import_dataverse7.val)(pointerToSheetState.sequence.tracksByObject[this.address.objectKey].trackIdByPropPath);
      const arrayOfIds = [];
      if (trackIdByPropPath) {
        for (const [pathToPropInString, trackId] of Object.entries(trackIdByPropPath)) {
          let pathToProp;
          try {
            pathToProp = JSON.parse(pathToPropInString);
          } catch (e2) {
            logger_default.warn(`property ${JSON.stringify(pathToPropInString)} cannot be parsed. Skipping.`);
            continue;
          }
          const defaultValue = get_default(defaults, pathToProp);
          if (typeof defaultValue !== "number") {
            continue;
          }
          arrayOfIds.push({ pathToProp, trackId });
        }
      } else {
        return emptyArray;
      }
      if (arrayOfIds.length === 0) {
        return emptyArray;
      } else {
        return arrayOfIds;
      }
    }));
  }
  getMapOfValidSequenceTracks_forStudio() {
    return this._cache.get("getMapOfValidSequenceTracks_forStudio", () => this.getArrayOfValidSequenceTracks().map((arr) => {
      let map = {};
      for (const { pathToProp, trackId } of arr) {
        set_default(map, pathToProp, trackId);
      }
      return map;
    }));
  }
  getDefaultsAtPointer(pointer3) {
    const { path } = (0, import_dataverse7.getPointerParts)(pointer3);
    const defaults = this.getDefaultValues().getValue();
    const defaultsAtPath = getDeep(defaults, path);
    return defaultsAtPath;
  }
};

// core/src/sheets/SheetTemplate.ts
var import_dataverse13 = __toModule(require("@theatre/dataverse"));

// shared/src/utils/didYouMean.ts
var import_propose = __toModule(require_propose());
function didYouMean(str, dictionary, prepend = "Did you mean ", append = "?") {
  const p2 = (0, import_propose.default)(str, dictionary, {
    threshold: 0.7
  });
  if (p2) {
    return prepend + JSON.stringify(p2) + append;
  } else {
    return "";
  }
}

// shared/src/utils/errors.ts
var TheatreError = class extends Error {
};
var InvalidArgumentError = class extends TheatreError {
};

// core/src/sequences/Sequence.ts
var import_dataverse10 = __toModule(require("@theatre/dataverse"));
var import_dataverse11 = __toModule(require("@theatre/dataverse"));

// ../node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
  var index = string2.length;
  while (index-- && reWhitespace.test(string2.charAt(index))) {
  }
  return index;
}
var trimmedEndIndex_default = trimmedEndIndex;

// ../node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex_default(string2) + 1).replace(reTrimStart, "") : string2;
}
var baseTrim_default = baseTrim;

// ../node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// ../node_modules/lodash-es/toFinite.js
var INFINITY3 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY3 || value === -INFINITY3) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// ../node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result = toFinite_default(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_default = toInteger;

// ../node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// ../node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// ../node_modules/lodash-es/isPlainObject.js
var objectTag = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto7 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty6 = objectProto7.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty6.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// ../node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var baseSlice_default = baseSlice;

// ../node_modules/lodash-es/_castSlice.js
function castSlice(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice_default(array, start, end);
}
var castSlice_default = castSlice;

// ../node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string2) {
  return reHasUnicode.test(string2);
}
var hasUnicode_default = hasUnicode;

// ../node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string2) {
  return string2.split("");
}
var asciiToArray_default = asciiToArray;

// ../node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string2) {
  return string2.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// ../node_modules/lodash-es/_stringToArray.js
function stringToArray(string2) {
  return hasUnicode_default(string2) ? unicodeToArray_default(string2) : asciiToArray_default(string2);
}
var stringToArray_default = stringToArray;

// ../node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// ../node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string2, n2) {
  var result = "";
  if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER2) {
    return result;
  }
  do {
    if (n2 % 2) {
      result += string2;
    }
    n2 = nativeFloor(n2 / 2);
    if (n2) {
      string2 += string2;
    }
  } while (n2);
  return result;
}
var baseRepeat_default = baseRepeat;

// ../node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// ../node_modules/lodash-es/_unicodeSize.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange3 + "]";
var rsCombo2 = "[" + rsComboRange3 + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo2 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ3 = "\\u200d";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsSymbol2 = "(?:" + [rsNonAstral2 + rsCombo2 + "?", rsCombo2, rsRegional2, rsSurrPair2, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz2 + "(?=" + rsFitz2 + ")|" + rsSymbol2 + rsSeq2, "g");
function unicodeSize(string2) {
  var result = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string2)) {
    ++result;
  }
  return result;
}
var unicodeSize_default = unicodeSize;

// ../node_modules/lodash-es/_stringSize.js
function stringSize(string2) {
  return hasUnicode_default(string2) ? unicodeSize_default(string2) : asciiSize_default(string2);
}
var stringSize_default = stringSize;

// ../node_modules/lodash-es/_createPadding.js
var nativeCeil = Math.ceil;
function createPadding(length, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length) : chars;
  }
  var result = baseRepeat_default(chars, nativeCeil(length / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result), 0, length).join("") : result.slice(0, length);
}
var createPadding_default = createPadding;

// ../node_modules/lodash-es/padStart.js
function padStart(string2, length, chars) {
  string2 = toString_default(string2);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string2) : 0;
  return length && strLength < length ? createPadding_default(length - strLength, chars) + string2 : string2;
}
var padStart_default = padStart;

// shared/src/utils/defer.ts
function defer() {
  let resolve;
  let reject;
  const promise = new Promise((rs, rj) => {
    resolve = (v2) => {
      rs(v2);
      deferred.status = "resolved";
    };
    reject = (v2) => {
      rj(v2);
      deferred.status = "rejected";
    };
  });
  const deferred = {
    resolve,
    reject,
    promise,
    status: "pending"
  };
  return deferred;
}

// shared/src/utils/noop.ts
var noop = () => {
};
var noop_default = noop;

// core/src/sequences/playbackControllers/DefaultPlaybackController.ts
var import_dataverse8 = __toModule(require("@theatre/dataverse"));
var DefaultPlaybackController = class {
  constructor(_ticker) {
    this._ticker = _ticker;
    __publicField(this, "_stopPlayCallback", noop_default);
    __publicField(this, "_state", new import_dataverse8.Atom({
      position: 0,
      playing: false
    }));
    __publicField(this, "statePointer");
    this.statePointer = this._state.pointer;
  }
  destroy() {
  }
  pause() {
    this._stopPlayCallback();
    this.playing = false;
    this._stopPlayCallback = noop_default;
  }
  gotoPosition(time) {
    this._updatePositionInState(time);
  }
  _updatePositionInState(time) {
    this._state.reduceState(["position"], () => time);
  }
  getCurrentPosition() {
    return this._state.getState().position;
  }
  get playing() {
    return this._state.getState().playing;
  }
  set playing(playing) {
    this._state.setIn(["playing"], playing);
  }
  play(iterationCount, range, rate, direction) {
    if (this.playing) {
      this.pause();
    }
    this.playing = true;
    const ticker = this._ticker;
    const iterationLength = range[1] - range[0];
    {
      const startPos = this.getCurrentPosition();
      if (startPos < range[0] || startPos > range[1]) {
        if (direction === "normal" || direction === "alternate") {
          this._updatePositionInState(range[0]);
        } else if (direction === "reverse" || direction === "alternateReverse") {
          this._updatePositionInState(range[1]);
        }
      } else if (direction === "normal" || direction === "alternate") {
        if (startPos === range[1]) {
          this._updatePositionInState(range[0]);
        }
      } else {
        if (startPos === range[0]) {
          this._updatePositionInState(range[1]);
        }
      }
    }
    const deferred = defer();
    const initialTickerTime = ticker.time;
    const totalPlaybackLength = iterationLength * iterationCount;
    let initialElapsedPos = this.getCurrentPosition() - range[0];
    if (direction === "reverse" || direction === "alternateReverse") {
      initialElapsedPos = range[1] - this.getCurrentPosition();
    }
    const tick = (currentTickerTime) => {
      const elapsedTickerTime = Math.max(currentTickerTime - initialTickerTime, 0);
      const elapsedTickerTimeInSeconds = elapsedTickerTime / 1e3;
      const elapsedPos = Math.min(elapsedTickerTimeInSeconds * rate + initialElapsedPos, totalPlaybackLength);
      if (elapsedPos !== totalPlaybackLength) {
        const iterationNumber = Math.floor(elapsedPos / iterationLength);
        let currentIterationPos = elapsedPos / iterationLength % 1 * iterationLength;
        if (direction !== "normal") {
          if (direction === "reverse") {
            currentIterationPos = iterationLength - currentIterationPos;
          } else {
            const isCurrentIterationNumberEven = iterationNumber % 2 === 0;
            if (direction === "alternate") {
              if (!isCurrentIterationNumberEven) {
                currentIterationPos = iterationLength - currentIterationPos;
              }
            } else {
              if (isCurrentIterationNumberEven) {
                currentIterationPos = iterationLength - currentIterationPos;
              }
            }
          }
        }
        this._updatePositionInState(currentIterationPos + range[0]);
        requestNextTick();
      } else {
        if (direction === "normal") {
          this._updatePositionInState(range[1]);
        } else if (direction === "reverse") {
          this._updatePositionInState(range[0]);
        } else {
          const isLastIterationEven = (iterationCount - 1) % 2 === 0;
          if (direction === "alternate") {
            if (isLastIterationEven) {
              this._updatePositionInState(range[1]);
            } else {
              this._updatePositionInState(range[0]);
            }
          } else {
            if (isLastIterationEven) {
              this._updatePositionInState(range[0]);
            } else {
              this._updatePositionInState(range[1]);
            }
          }
        }
        this.playing = false;
        deferred.resolve(true);
      }
    };
    this._stopPlayCallback = () => {
      ticker.offThisOrNextTick(tick);
      ticker.offNextTick(tick);
      if (this.playing)
        deferred.resolve(false);
    };
    const requestNextTick = () => ticker.onNextTick(tick);
    ticker.onThisOrNextTick(tick);
    return deferred.promise;
  }
};

// core/src/sequences/playbackControllers/AudioPlaybackController.ts
var import_dataverse9 = __toModule(require("@theatre/dataverse"));
var AudioPlaybackController = class {
  constructor(_ticker, _decodedBuffer, _audioContext, _nodeDestination) {
    this._ticker = _ticker;
    this._decodedBuffer = _decodedBuffer;
    this._audioContext = _audioContext;
    this._nodeDestination = _nodeDestination;
    __publicField(this, "_mainGain");
    __publicField(this, "_state", new import_dataverse9.Atom({
      position: 0,
      playing: false
    }));
    __publicField(this, "statePointer");
    __publicField(this, "_stopPlayCallback", noop_default);
    this.statePointer = this._state.pointer;
    this._mainGain = this._audioContext.createGain();
    this._mainGain.connect(this._nodeDestination);
  }
  get _playing() {
    return this._state.getState().playing;
  }
  set _playing(playing) {
    this._state.setIn(["playing"], playing);
  }
  destroy() {
  }
  pause() {
    this._stopPlayCallback();
    this._playing = false;
    this._stopPlayCallback = noop_default;
  }
  gotoPosition(time) {
    this._updatePositionInState(time);
  }
  _updatePositionInState(time) {
    this._state.reduceState(["position"], () => time);
  }
  getCurrentPosition() {
    return this._state.getState().position;
  }
  play(iterationCount, range, rate, direction) {
    if (this._playing) {
      this.pause();
    }
    this._playing = true;
    const ticker = this._ticker;
    let startPos = this.getCurrentPosition();
    const iterationLength = range[1] - range[0];
    if (direction !== "normal") {
      throw new InvalidArgumentError(`Audio-controlled sequences can only be played in the "normal" direction. '${direction}' given.`);
    }
    if (startPos < range[0] || startPos > range[1]) {
      this._updatePositionInState(range[0]);
    } else if (startPos === range[1]) {
      this._updatePositionInState(range[0]);
    }
    startPos = this.getCurrentPosition();
    const deferred = defer();
    const currentSource = this._audioContext.createBufferSource();
    currentSource.buffer = this._decodedBuffer;
    currentSource.connect(this._mainGain);
    currentSource.playbackRate.value = rate;
    if (iterationCount > 1e3) {
      console.warn(`Audio-controlled sequences cannot have an iterationCount larger than 1000. It has been clamped to 1000.`);
      iterationCount = 1e3;
    }
    if (iterationCount > 1) {
      currentSource.loop = true;
      currentSource.loopStart = range[0];
      currentSource.loopEnd = range[1];
    }
    const initialTickerTime = ticker.time;
    let initialElapsedPos = startPos - range[0];
    const totalPlaybackLength = iterationLength * iterationCount;
    currentSource.start(0, startPos, totalPlaybackLength - initialElapsedPos);
    const tick = (currentTickerTime) => {
      const elapsedTickerTime = Math.max(currentTickerTime - initialTickerTime, 0);
      const elapsedTickerTimeInSeconds = elapsedTickerTime / 1e3;
      const elapsedPos = Math.min(elapsedTickerTimeInSeconds * rate + initialElapsedPos, totalPlaybackLength);
      if (elapsedPos !== totalPlaybackLength) {
        let currentIterationPos = elapsedPos / iterationLength % 1 * iterationLength;
        this._updatePositionInState(currentIterationPos + range[0]);
        requestNextTick();
      } else {
        this._updatePositionInState(range[1]);
        this._playing = false;
        cleanup();
        deferred.resolve(true);
      }
    };
    const cleanup = () => {
      currentSource.stop();
      currentSource.disconnect();
    };
    this._stopPlayCallback = () => {
      cleanup();
      ticker.offThisOrNextTick(tick);
      ticker.offNextTick(tick);
      if (this._playing)
        deferred.resolve(false);
    };
    const requestNextTick = () => ticker.onNextTick(tick);
    ticker.onThisOrNextTick(tick);
    return deferred.promise;
  }
};

// core/src/sequences/TheatreSequence.ts
var TheatreSequence = class {
  get type() {
    return "Theatre_Sequence_PublicAPI";
  }
  constructor(sheet) {
    setPrivateAPI(this, sheet);
  }
  play(conf) {
    if (privateAPI(this)._project.isReady()) {
      return privateAPI(this).play(conf);
    } else {
      if (process.env.NODE_ENV !== "production") {
        logger_default.warn(`You seem to have called sequence.play() before the project has finished loading.
This would **not** a problem in production when using '@theatre/core', since Theatre loads instantly in core mode. However, when using '@theatre/studio', it takes a few milliseconds for it to load your project's state, before which your sequences cannot start playing.

To fix this, simply defer calling sequence.play() until after the project is loaded, like this:
project.ready.then(() => {
  sequence.play()
})`);
      }
      const d2 = defer();
      d2.resolve(true);
      return d2.promise;
    }
  }
  pause() {
    privateAPI(this).pause();
  }
  get position() {
    return privateAPI(this).position;
  }
  set position(position) {
    privateAPI(this).position = position;
  }
  async attachAudio(args) {
    const { audioContext, destinationNode, decodedBuffer, gainNode } = await resolveAudioBuffer(args);
    const playbackController = new AudioPlaybackController(coreTicker_default, decodedBuffer, audioContext, gainNode);
    privateAPI(this).replacePlaybackController(playbackController);
    return { audioContext, destinationNode, decodedBuffer, gainNode };
  }
  get pointer() {
    return privateAPI(this).pointer;
  }
};
async function resolveAudioBuffer(args) {
  function getAudioContext() {
    if (args.audioContext)
      return Promise.resolve(args.audioContext);
    const ctx = new AudioContext();
    if (ctx.state === "running")
      return Promise.resolve(ctx);
    return new Promise((resolve) => {
      const listener = () => {
        ctx.resume();
      };
      const eventsToHookInto = [
        "mousedown",
        "keydown",
        "touchstart"
      ];
      const eventListenerOpts = { capture: true, passive: false };
      eventsToHookInto.forEach((eventName) => {
        window.addEventListener(eventName, listener, eventListenerOpts);
      });
      ctx.addEventListener("statechange", () => {
        if (ctx.state === "running") {
          eventsToHookInto.forEach((eventName) => {
            window.removeEventListener(eventName, listener, eventListenerOpts);
          });
          resolve(ctx);
        }
      });
    });
  }
  async function getAudioBuffer() {
    if (args.source instanceof AudioBuffer) {
      return args.source;
    }
    const decodedBufferDeferred = defer();
    if (typeof args.source !== "string") {
      throw new Error(`Error validating arguments to sequence.attachAudio(). args.source must either be a string or an instance of AudioBuffer.`);
    }
    let fetchResponse;
    try {
      fetchResponse = await fetch(args.source);
    } catch (e2) {
      console.error(e2);
      throw new Error(`Could not fetch '${args.source}'. Network error logged above.`);
    }
    let arrayBuffer;
    try {
      arrayBuffer = await fetchResponse.arrayBuffer();
    } catch (e2) {
      console.error(e2);
      throw new Error(`Could not read '${args.source}' as an arrayBuffer.`);
    }
    const audioContext2 = await audioContextPromise;
    audioContext2.decodeAudioData(arrayBuffer, decodedBufferDeferred.resolve, decodedBufferDeferred.reject);
    let decodedBuffer2;
    try {
      decodedBuffer2 = await decodedBufferDeferred.promise;
    } catch (e2) {
      console.error(e2);
      throw new Error(`Could not decode ${args.source} as an audio file.`);
    }
    return decodedBuffer2;
  }
  const audioContextPromise = getAudioContext();
  const audioBufferPromise = getAudioBuffer();
  const [audioContext, decodedBuffer] = await Promise.all([
    audioContextPromise,
    audioBufferPromise
  ]);
  const destinationNode = args.destinationNode || audioContext.destination;
  const gainNode = audioContext.createGain();
  gainNode.connect(destinationNode);
  return {
    audioContext,
    decodedBuffer,
    gainNode,
    destinationNode
  };
}

// core/src/sequences/Sequence.ts
var possibleDirections = [
  "normal",
  "reverse",
  "alternate",
  "alternateReverse"
];
var Sequence = class {
  constructor(_project, _sheet, _lengthD, _subUnitsPerUnitD, playbackController) {
    this._project = _project;
    this._sheet = _sheet;
    this._lengthD = _lengthD;
    this._subUnitsPerUnitD = _subUnitsPerUnitD;
    __publicField(this, "address");
    __publicField(this, "publicApi");
    __publicField(this, "_playbackControllerBox");
    __publicField(this, "_statePointerDerivation");
    __publicField(this, "_positionD");
    __publicField(this, "_positionFormatterD");
    __publicField(this, "_playableRangeD");
    __publicField(this, "pointer", (0, import_dataverse10.pointer)({ root: this, path: [] }));
    __publicField(this, "$$isIdentityDerivationProvider", true);
    __publicField(this, "closestGridPosition", (posInUnitSpace) => {
      const subUnitsPerUnit = this.subUnitsPerUnit;
      const gridLength = 1 / subUnitsPerUnit;
      return parseFloat((Math.round(posInUnitSpace / gridLength) * gridLength).toFixed(3));
    });
    this.address = __spreadProps(__spreadValues({}, this._sheet.address), { sequenceName: "default" });
    this.publicApi = new TheatreSequence(this);
    this._playbackControllerBox = new import_dataverse11.Box(playbackController != null ? playbackController : new DefaultPlaybackController(coreTicker_default));
    this._statePointerDerivation = this._playbackControllerBox.derivation.map((playbackController2) => playbackController2.statePointer);
    this._positionD = this._statePointerDerivation.flatMap((statePointer) => (0, import_dataverse11.valueDerivation)(statePointer.position));
    this._positionFormatterD = this._subUnitsPerUnitD.map((subUnitsPerUnit) => new TimeBasedPositionFormatter(subUnitsPerUnit));
  }
  getIdentityDerivation(path) {
    if (path.length === 0) {
      return (0, import_dataverse11.prism)(() => ({
        length: (0, import_dataverse11.val)(this.pointer.length),
        playing: (0, import_dataverse11.val)(this.pointer.playing),
        position: (0, import_dataverse11.val)(this.pointer.position)
      }));
    }
    if (path.length > 1) {
      return (0, import_dataverse11.prism)(() => void 0);
    }
    const [prop] = path;
    if (prop === "length") {
      return this._lengthD;
    } else if (prop === "position") {
      return this._positionD;
    } else if (prop === "playing") {
      return (0, import_dataverse11.prism)(() => {
        return (0, import_dataverse11.val)(this._statePointerDerivation.getValue().playing);
      });
    } else {
      return (0, import_dataverse11.prism)(() => void 0);
    }
  }
  get positionFormatter() {
    return this._positionFormatterD.getValue();
  }
  get derivationToStatePointer() {
    return this._statePointerDerivation;
  }
  get length() {
    return this._lengthD.getValue();
  }
  get positionDerivation() {
    return this._positionD;
  }
  get position() {
    return this._playbackControllerBox.get().getCurrentPosition();
  }
  get subUnitsPerUnit() {
    return this._subUnitsPerUnitD.getValue();
  }
  get positionSnappedToGrid() {
    return this.closestGridPosition(this.position);
  }
  set position(requestedPosition) {
    let position = requestedPosition;
    this.pause();
    if (process.env.NODE_ENV !== "production") {
      if (typeof position !== "number") {
        logger_default.error(`value t in sequence.position = t must be a number. ${typeof position} given`);
        position = 0;
      }
      if (position < 0) {
        logger_default.error(`sequence.position must be a positive number. ${position} given`);
        position = 0;
      }
    }
    if (position > this.length) {
      position = this.length;
    }
    const dur = this.length;
    this._playbackControllerBox.get().gotoPosition(position > dur ? dur : position);
  }
  getDurationCold() {
    return this._lengthD.getValue();
  }
  get playing() {
    return (0, import_dataverse11.val)(this._playbackControllerBox.get().statePointer.playing);
  }
  _makeRangeFromSequenceTemplate() {
    return (0, import_dataverse11.prism)(() => {
      return [0, (0, import_dataverse11.val)(this._lengthD)];
    });
  }
  async play(conf) {
    const sequenceDuration = this.length;
    const range = conf && conf.range ? conf.range : [0, sequenceDuration];
    if (process.env.NODE_ENV !== "production") {
      if (typeof range[0] !== "number" || range[0] < 0) {
        throw new InvalidArgumentError(`Argument conf.range[0] in sequence.play(conf) must be a positive number. ${JSON.stringify(range[0])} given.`);
      }
      if (range[0] >= sequenceDuration) {
        throw new InvalidArgumentError(`Argument conf.range[0] in sequence.play(conf) cannot be longer than the duration of the sequence, which is ${sequenceDuration}s. ${JSON.stringify(range[0])} given.`);
      }
      if (typeof range[1] !== "number" || range[1] <= 0) {
        throw new InvalidArgumentError(`Argument conf.range[1] in sequence.play(conf) must be a number larger than zero. ${JSON.stringify(range[1])} given.`);
      }
      if (range[1] > sequenceDuration) {
        logger_default.warn(`Argument conf.range[1] in sequence.play(conf) cannot be longer than the duration of the sequence, which is ${sequenceDuration}s. ${JSON.stringify(range[1])} given.`);
        range[1] = sequenceDuration;
      }
      if (range[1] <= range[0]) {
        throw new InvalidArgumentError(`Argument conf.range[1] in sequence.play(conf) must be larger than conf.range[0]. ${JSON.stringify(range)} given.`);
      }
    }
    const iterationCount = conf && typeof conf.iterationCount === "number" ? conf.iterationCount : 1;
    if (process.env.NODE_ENV !== "production") {
      if (!(Number.isInteger(iterationCount) && iterationCount > 0) && iterationCount !== Infinity) {
        throw new InvalidArgumentError(`Argument conf.iterationCount in sequence.play(conf) must be an integer larger than 0. ${JSON.stringify(iterationCount)} given.`);
      }
    }
    const rate = conf && typeof conf.rate !== "undefined" ? conf.rate : 1;
    if (process.env.NODE_ENV !== "production") {
      if (typeof rate !== "number" || rate === 0) {
        throw new InvalidArgumentError(`Argument conf.rate in sequence.play(conf) must be a number larger than 0. ${JSON.stringify(rate)} given.`);
      }
      if (rate < 0) {
        throw new InvalidArgumentError(`Argument conf.rate in sequence.play(conf) must be a number larger than 0. ${JSON.stringify(rate)} given. If you want the animation to play backwards, try setting conf.direction to 'reverse' or 'alternateReverse'.`);
      }
    }
    const direction = conf && conf.direction ? conf.direction : "normal";
    if (process.env.NODE_ENV !== "production") {
      if (possibleDirections.indexOf(direction) === -1) {
        throw new InvalidArgumentError(`Argument conf.direction in sequence.play(conf) must be one of ${JSON.stringify(possibleDirections)}. ${JSON.stringify(direction)} given. ${didYouMean(direction, possibleDirections)}`);
      }
    }
    return await this._play(iterationCount, [range[0], range[1]], rate, direction);
  }
  _play(iterationCount, range, rate, direction) {
    return this._playbackControllerBox.get().play(iterationCount, range, rate, direction);
  }
  pause() {
    this._playbackControllerBox.get().pause();
  }
  replacePlaybackController(playbackController) {
    this.pause();
    const oldController = this._playbackControllerBox.get();
    this._playbackControllerBox.set(playbackController);
    const time = oldController.getCurrentPosition();
    oldController.destroy();
    playbackController.gotoPosition(time);
  }
};
var TimeBasedPositionFormatter = class {
  constructor(_fps) {
    this._fps = _fps;
  }
  formatSubUnitForGrid(posInUnitSpace) {
    const subSecondPos = posInUnitSpace % 1;
    const frame = 1 / this._fps;
    const frames = Math.round(subSecondPos / frame);
    return frames + "f";
  }
  formatFullUnitForGrid(posInUnitSpace) {
    let p2 = posInUnitSpace;
    let s2 = "";
    if (p2 >= hour) {
      const hours = Math.floor(p2 / hour);
      s2 += hours + "h";
      p2 = p2 % hour;
    }
    if (p2 >= minute) {
      const minutes = Math.floor(p2 / minute);
      s2 += minutes + "m";
      p2 = p2 % minute;
    }
    if (p2 >= second) {
      const seconds = Math.floor(p2 / second);
      s2 += seconds + "s";
      p2 = p2 % second;
    }
    const frame = 1 / this._fps;
    if (p2 >= frame) {
      const frames = Math.floor(p2 / frame);
      s2 += frames + "f";
      p2 = p2 % frame;
    }
    return s2.length === 0 ? "0s" : s2;
  }
  formatForPlayhead(posInUnitSpace) {
    let p2 = posInUnitSpace;
    let s2 = "";
    if (p2 >= hour) {
      const hours = Math.floor(p2 / hour);
      s2 += padStart_default(hours.toString(), 2, "0") + "h";
      p2 = p2 % hour;
    }
    if (p2 >= minute) {
      const minutes = Math.floor(p2 / minute);
      s2 += padStart_default(minutes.toString(), 2, "0") + "m";
      p2 = p2 % minute;
    } else if (s2.length > 0) {
      s2 += "00m";
    }
    if (p2 >= second) {
      const seconds = Math.floor(p2 / second);
      s2 += padStart_default(seconds.toString(), 2, "0") + "s";
      p2 = p2 % second;
    } else {
      s2 += "00s";
    }
    const frameLength = 1 / this._fps;
    if (p2 >= frameLength) {
      const frames = Math.round(p2 / frameLength);
      s2 += padStart_default(frames.toString(), 2, "0") + "f";
      p2 = p2 % frameLength;
    } else if (p2 / frameLength > 0.98) {
      const frames = 1;
      s2 += padStart_default(frames.toString(), 2, "0") + "f";
      p2 = p2 % frameLength;
    } else {
      s2 += "00f";
    }
    return s2.length === 0 ? "00s00f" : s2;
  }
  formatBasic(posInUnitSpace) {
    return posInUnitSpace.toFixed(2) + "s";
  }
};
var second = 1;
var minute = second * 60;
var hour = minute * 60;

// core/src/propTypes/index.ts
var propTypes_exports = {};
__export(propTypes_exports, {
  boolean: () => boolean,
  compound: () => compound,
  number: () => number,
  string: () => string,
  stringLiteral: () => stringLiteral
});

// shared/src/utils/ellipsify.ts
function ellipsify(str, maxLength) {
  if (str.length <= maxLength)
    return str;
  return str.substr(0, maxLength - 3) + "...";
}

// shared/src/utils/userReadableTypeOfValue.ts
var userReadableTypeOfValue = (v2) => {
  if (typeof v2 === "string") {
    return `string("${ellipsify(v2, 10)}")`;
  } else if (typeof v2 === "number") {
    return `number(${ellipsify(String(v2), 10)})`;
  } else if (v2 === null) {
    return "null";
  } else if (v2 === void 0) {
    return "undefined";
  } else if (typeof v2 === "boolean") {
    return String(v2);
  } else if (Array.isArray(v2)) {
    return "array";
  } else if (typeof v2 === "object") {
    return "object";
  } else {
    return "unknown";
  }
};
var userReadableTypeOfValue_default = userReadableTypeOfValue;

// core/src/propTypes/internals.ts
var propTypeSymbol = Symbol("TheatrePropType_Basic");
function isLonghandPropType(t3) {
  return typeof t3 === "object" && !!t3 && t3[propTypeSymbol] === "TheatrePropType";
}
function toLonghandProp(p2) {
  if (typeof p2 === "number") {
    return number(p2);
  } else if (typeof p2 === "boolean") {
    return boolean(p2);
  } else if (typeof p2 === "string") {
    return string(p2);
  } else if (typeof p2 === "object" && !!p2) {
    if (isLonghandPropType(p2))
      return p2;
    if (isPlainObject_default(p2)) {
      return compound(p2);
    } else {
      throw new InvalidArgumentError(`This value is not a valid prop type: ${userReadableTypeOfValue_default(p2)}`);
    }
  } else {
    throw new InvalidArgumentError(`This value is not a valid prop type: ${userReadableTypeOfValue_default(p2)}`);
  }
}
function sanitizeCompoundProps(props) {
  const sanitizedProps = {};
  if (process.env.NODE_ENV !== "production") {
    if (typeof props !== "object" || !props) {
      throw new InvalidArgumentError(`t.compound() expects an object, like: {x: 10}. ${userReadableTypeOfValue_default(props)} given.`);
    }
  }
  for (const key of Object.keys(props)) {
    if (process.env.NODE_ENV !== "production") {
      if (typeof key !== "string") {
        throw new InvalidArgumentError(`t.compound()'s keys must be all strings. ${userReadableTypeOfValue_default(key)} given.`);
      } else if (key.length === 0 || !key.match(/^\w+$/)) {
        throw new InvalidArgumentError(`compound key ${userReadableTypeOfValue_default(key)} is invalid. The keys must be alphanumeric and start with a letter.`);
      } else if (key.length > 64) {
        throw new InvalidArgumentError(`compound key ${userReadableTypeOfValue_default(key)} is too long.`);
      }
    }
    const val7 = props[key];
    if (isLonghandPropType(val7)) {
      sanitizedProps[key] = val7;
    } else {
      sanitizedProps[key] = toLonghandProp(val7);
    }
  }
  return sanitizedProps;
}

// core/src/propTypes/index.ts
var validateCommonOpts = (fnCallSignature, opts) => {
  if (process.env.NODE_ENV !== "production") {
    if (opts === void 0)
      return;
    if (typeof opts !== "object" || opts === null) {
      throw new Error(`opts in ${fnCallSignature} must either be undefined or an object.`);
    }
    if (Object.prototype.hasOwnProperty.call(opts, "label")) {
      const { label } = opts;
      if (typeof label !== "string") {
        throw new Error(`opts.label in ${fnCallSignature} should be a string. ${userReadableTypeOfValue_default(label)} given.`);
      }
      if (label.trim().length !== label.length) {
        throw new Error(`opts.label in ${fnCallSignature} should not start/end with whitespace. "${label}" given.`);
      }
      if (label.length === 0) {
        throw new Error(`opts.label in ${fnCallSignature} should not be an empty string. If you wish to have no label, remove opts.label from opts.`);
      }
    }
  }
};
var compound = (props, opts) => {
  validateCommonOpts("t.compound(props, opts)", opts);
  return {
    type: "compound",
    props: sanitizeCompoundProps(props),
    valueType: null,
    [propTypeSymbol]: "TheatrePropType",
    label: opts == null ? void 0 : opts.label
  };
};
var number = (defaultValue, opts) => {
  var _a;
  if (process.env.NODE_ENV !== "production") {
    validateCommonOpts("t.number(defaultValue, opts)", opts);
    if (typeof defaultValue !== "number" || !isFinite(defaultValue)) {
      throw new Error(`Argument defaultValue in t.number(defaultValue) must be a number. ${userReadableTypeOfValue_default(defaultValue)} given.`);
    }
    if (typeof opts === "object" && opts !== null) {
      if (Object.prototype.hasOwnProperty.call(opts, "range")) {
        if (!Array.isArray(opts.range)) {
          throw new Error(`opts.range in t.number(defaultValue, opts) must be a tuple of two numbers. ${userReadableTypeOfValue_default(opts.range)} given.`);
        }
        if (opts.range.length !== 2) {
          throw new Error(`opts.range in t.number(defaultValue, opts) must have two elements. ${opts.range.length} given.`);
        }
        if (!opts.range.every((n2) => typeof n2 === "number" && !isNaN(n2))) {
          throw new Error(`opts.range in t.number(defaultValue, opts) must be a tuple of two numbers.`);
        }
        if (opts.range[0] >= opts.range[1]) {
          throw new Error(`opts.range[0] in t.number(defaultValue, opts) must be smaller than opts.range[1]. Given: ${JSON.stringify(opts.range)}`);
        }
      }
      if (Object.prototype.hasOwnProperty.call(opts, "nudgeMultiplier")) {
        if (typeof opts.nudgeMultiplier !== "number" || !isFinite(opts.nudgeMultiplier)) {
          throw new Error(`opts.nudgeMultiplier in t.number(defaultValue, opts) must be a finite number. ${userReadableTypeOfValue_default(opts.nudgeMultiplier)} given.`);
        }
      }
      if (Object.prototype.hasOwnProperty.call(opts, "nudgeFn")) {
        if (typeof (opts == null ? void 0 : opts.nudgeFn) !== "function") {
          throw new Error(`opts.nudgeFn in t.number(defaultValue, opts) must be a function. ${userReadableTypeOfValue_default(opts.nudgeFn)} given.`);
        }
      }
    }
  }
  return __spreadProps(__spreadValues({
    type: "number",
    valueType: 0,
    default: defaultValue,
    [propTypeSymbol]: "TheatrePropType"
  }, opts ? opts : {}), {
    label: opts == null ? void 0 : opts.label,
    nudgeFn: (_a = opts == null ? void 0 : opts.nudgeFn) != null ? _a : defaultNumberNudgeFn,
    nudgeMultiplier: typeof (opts == null ? void 0 : opts.nudgeMultiplier) === "number" ? opts.nudgeMultiplier : 1
  });
};
var boolean = (defaultValue, opts) => {
  if (process.env.NODE_ENV !== "production") {
    validateCommonOpts("t.boolean(defaultValue, opts)", opts);
    if (typeof defaultValue !== "boolean") {
      throw new Error(`defaultValue in t.boolean(defaultValue) must be a boolean. ${userReadableTypeOfValue_default(defaultValue)} given.`);
    }
  }
  return {
    type: "boolean",
    default: defaultValue,
    valueType: null,
    [propTypeSymbol]: "TheatrePropType",
    label: opts == null ? void 0 : opts.label
  };
};
var string = (defaultValue, opts) => {
  if (process.env.NODE_ENV !== "production") {
    validateCommonOpts("t.string(defaultValue, opts)", opts);
    if (typeof defaultValue !== "string") {
      throw new Error(`defaultValue in t.string(defaultValue) must be a string. ${userReadableTypeOfValue_default(defaultValue)} given.`);
    }
  }
  return {
    type: "string",
    default: defaultValue,
    valueType: null,
    [propTypeSymbol]: "TheatrePropType",
    label: opts == null ? void 0 : opts.label
  };
};
function stringLiteral(defaultValue, options, opts) {
  var _a;
  return {
    type: "stringLiteral",
    default: defaultValue,
    options: __spreadValues({}, options),
    [propTypeSymbol]: "TheatrePropType",
    valueType: null,
    as: (_a = opts == null ? void 0 : opts.as) != null ? _a : "menu",
    label: opts == null ? void 0 : opts.label
  };
}
var defaultNumberNudgeFn = ({
  config,
  deltaX,
  deltaFraction,
  magnitude
}) => {
  const { range } = config;
  if (range) {
    return deltaFraction * (range[1] - range[0]) * magnitude * config.nudgeMultiplier;
  }
  return deltaX * magnitude * config.nudgeMultiplier;
};

// shared/src/utils/slashedPaths.ts
var sanifySlashedPath = (p2) => p2.replace(/^[\s\/]*/, "").replace(/[\s\/]*$/, "").replace(/\s*\/\s*/, " / ");
var getValidationErrorsOfSlashedPath = (p2) => {
  if (typeof p2 !== "string")
    return `it is not a string. (it is a ${typeof p2})`;
  const components = p2.split(/\//);
  if (components.length === 0)
    return `it is empty.`;
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2].trim();
    if (component.length === 0)
      return `the component #${i2 + 1} is empty.`;
    if (component.length > 32)
      return `the component '${component}' must have 32 characters or less.`;
  }
};
function validateAndSanitiseSlashedPathOrThrow(unsanitisedPath, fnName) {
  const sanitisedPath = sanifySlashedPath(unsanitisedPath);
  if (process.env.NODE_ENV !== "development") {
    return sanitisedPath;
  }
  const validation = getValidationErrorsOfSlashedPath(sanitisedPath);
  if (validation) {
    throw new InvalidArgumentError(`The path in ${fnName}(${typeof unsanitisedPath === "string" ? `"${unsanitisedPath}"` : ""}) is invalid because ${validation}`);
  }
  if (unsanitisedPath !== sanitisedPath) {
    logger_default.warn(`The path in ${fnName}("${unsanitisedPath}") was sanitised to "${sanitisedPath}".`);
  }
  return sanitisedPath;
}

// core/src/sheets/TheatreSheet.ts
var import_fast_deep_equal = __toModule(require_fast_deep_equal());
var weakMapOfUnsanitizedProps = new WeakMap();
var TheatreSheet = class {
  get type() {
    return "Theatre_Sheet_PublicAPI";
  }
  constructor(sheet) {
    setPrivateAPI(this, sheet);
  }
  object(key, config) {
    const internal = privateAPI(this);
    const sanitizedPath = validateAndSanitiseSlashedPathOrThrow(key, `sheet.object("${key}", ...)`);
    const existingObject = internal.getObject(sanitizedPath);
    const nativeObject = null;
    if (existingObject) {
      if (process.env.NODE_ENV !== "production") {
        const prevConfig = weakMapOfUnsanitizedProps.get(existingObject);
        if (prevConfig) {
          if (!(0, import_fast_deep_equal.default)(config, prevConfig)) {
            throw new Error(`You seem to have called sheet.object("${key}", config) twice, with different values for \`config\`. This is disallowed because changing the config of an object on the fly would make it difficult to reason about.

You can fix this by either re-using the existing object, or calling sheet.object("${key}", config) with the same config.`);
          }
        }
      }
      return existingObject.publicApi;
    } else {
      const sanitizedConfig = compound(config);
      const object = internal.createObject(sanitizedPath, nativeObject, sanitizedConfig);
      if (process.env.NODE_ENV !== "production") {
        weakMapOfUnsanitizedProps.set(object, config);
      }
      return object.publicApi;
    }
  }
  get sequence() {
    return privateAPI(this).getSequence().publicApi;
  }
  get project() {
    return privateAPI(this).project.publicApi;
  }
  get address() {
    return __spreadValues({}, privateAPI(this).address);
  }
};

// core/src/sheets/Sheet.ts
var import_dataverse12 = __toModule(require("@theatre/dataverse"));
var Sheet = class {
  constructor(template, instanceId) {
    this.template = template;
    this.instanceId = instanceId;
    __publicField(this, "_objects", new import_dataverse12.Atom({}));
    __publicField(this, "_sequence");
    __publicField(this, "address");
    __publicField(this, "publicApi");
    __publicField(this, "project");
    __publicField(this, "objectsP", this._objects.pointer);
    __publicField(this, "type", "Theatre_Sheet");
    this.project = template.project;
    this.address = __spreadProps(__spreadValues({}, template.address), {
      sheetInstanceId: this.instanceId
    });
    this.publicApi = new TheatreSheet(this);
  }
  createObject(key, nativeObject, config) {
    const objTemplate = this.template.getObjectTemplate(key, nativeObject, config);
    const object = objTemplate.createInstance(this, nativeObject, config);
    this._objects.setIn([key], object);
    return object;
  }
  getObject(key) {
    return this._objects.getState()[key];
  }
  getSequence() {
    if (!this._sequence) {
      const lengthD = (0, import_dataverse12.valueDerivation)(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.length).map((s2) => typeof s2 === "number" ? s2 : 10);
      const subUnitsPerUnitD = (0, import_dataverse12.valueDerivation)(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.subUnitsPerUnit).map((s2) => typeof s2 === "number" ? s2 : 30);
      this._sequence = new Sequence(this.template.project, this, lengthD, subUnitsPerUnitD);
    }
    return this._sequence;
  }
};

// core/src/sheets/SheetTemplate.ts
var SheetTemplate = class {
  constructor(project, sheetId) {
    this.project = project;
    __publicField(this, "type", "Theatre_SheetTemplate");
    __publicField(this, "address");
    __publicField(this, "_instances", new import_dataverse13.Atom({}));
    __publicField(this, "instancesP", this._instances.pointer);
    __publicField(this, "_objectTemplates", new import_dataverse13.Atom({}));
    __publicField(this, "objectTemplatesP", this._objectTemplates.pointer);
    this.address = __spreadProps(__spreadValues({}, project.address), { sheetId });
  }
  getInstance(instanceId) {
    let inst = this._instances.getState()[instanceId];
    if (!inst) {
      inst = new Sheet(this, instanceId);
      this._instances.setIn([instanceId], inst);
    }
    return inst;
  }
  getObjectTemplate(key, nativeObject, config) {
    let template = this._objectTemplates.getState()[key];
    if (!template) {
      template = new SheetObjectTemplate(this, key, nativeObject, config);
      this._objectTemplates.setIn([key], template);
    }
    return template;
  }
};

// core/src/projects/Project.ts
var import_dataverse14 = __toModule(require("@theatre/dataverse"));
var import_dataverse15 = __toModule(require("@theatre/dataverse"));

// shared/src/utils/delay.ts
var delay = (dur) => new Promise((resolve) => setTimeout(resolve, dur));
var delay_default = delay;

// ../node_modules/immer/dist/immer.esm.js
function n(n2) {
  for (var t3 = arguments.length, r2 = Array(t3 > 1 ? t3 - 1 : 0), e2 = 1; e2 < t3; e2++)
    r2[e2 - 1] = arguments[e2];
  if (process.env.NODE_ENV !== "production") {
    var i2 = Y[n2], o2 = i2 ? typeof i2 == "function" ? i2.apply(null, r2) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
  throw Error("[Immer] minified error nr: " + n2 + (r2.length ? " " + r2.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function t2(n2) {
  return !!n2 && !!n2[Q];
}
function r(n2) {
  return !!n2 && (function(n3) {
    if (!n3 || typeof n3 != "object")
      return false;
    var t3 = Object.getPrototypeOf(n3);
    if (t3 === null)
      return true;
    var r2 = Object.hasOwnProperty.call(t3, "constructor") && t3.constructor;
    return r2 === Object || typeof r2 == "function" && Function.toString.call(r2) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!n2.constructor[L] || s(n2) || v(n2));
}
function e(r2) {
  return t2(r2) || n(23, r2), r2[Q].t;
}
function i(n2, t3, r2) {
  r2 === void 0 && (r2 = false), o(n2) === 0 ? (r2 ? Object.keys : nn)(n2).forEach(function(e2) {
    r2 && typeof e2 == "symbol" || t3(e2, n2[e2], n2);
  }) : n2.forEach(function(r3, e2) {
    return t3(e2, r3, n2);
  });
}
function o(n2) {
  var t3 = n2[Q];
  return t3 ? t3.i > 3 ? t3.i - 4 : t3.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, t3) {
  return o(n2) === 2 ? n2.has(t3) : Object.prototype.hasOwnProperty.call(n2, t3);
}
function a(n2, t3) {
  return o(n2) === 2 ? n2.get(t3) : n2[t3];
}
function f(n2, t3, r2) {
  var e2 = o(n2);
  e2 === 2 ? n2.set(t3, r2) : e2 === 3 ? (n2.delete(t3), n2.add(r2)) : n2[t3] = r2;
}
function c(n2, t3) {
  return n2 === t3 ? n2 !== 0 || 1 / n2 == 1 / t3 : n2 != n2 && t3 != t3;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var t3 = tn(n2);
  delete t3[Q];
  for (var r2 = nn(t3), e2 = 0; e2 < r2.length; e2++) {
    var i2 = r2[e2], o2 = t3[i2];
    o2.writable === false && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (t3[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), t3);
}
function d(n2, e2) {
  return e2 === void 0 && (e2 = false), y(n2) || t2(n2) || !r(n2) ? n2 : (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e2 && i(n2, function(n3, t3) {
    return d(t3, true);
  }, true), n2);
}
function h() {
  n(2);
}
function y(n2) {
  return n2 == null || typeof n2 != "object" || Object.isFrozen(n2);
}
function b(t3) {
  var r2 = rn[t3];
  return r2 || n(18, t3), r2;
}
function _() {
  return process.env.NODE_ENV === "production" || U || n(0), U;
}
function j(n2, t3) {
  t3 && (b("Patches"), n2.u = [], n2.s = [], n2.v = t3);
}
function O(n2) {
  g(n2), n2.p.forEach(S), n2.p = null;
}
function g(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var t3 = n2[Q];
  t3.i === 0 || t3.i === 1 ? t3.j() : t3.O = true;
}
function P(t3, e2) {
  e2._ = e2.p.length;
  var i2 = e2.p[0], o2 = t3 !== void 0 && t3 !== i2;
  return e2.h.g || b("ES5").S(e2, t3, o2), o2 ? (i2[Q].P && (O(e2), n(4)), r(t3) && (t3 = M(e2, t3), e2.l || x(e2, t3)), e2.u && b("Patches").M(i2[Q], t3, e2.u, e2.s)) : t3 = M(e2, i2, []), O(e2), e2.u && e2.v(e2.u, e2.s), t3 !== H ? t3 : void 0;
}
function M(n2, t3, r2) {
  if (y(t3))
    return t3;
  var e2 = t3[Q];
  if (!e2)
    return i(t3, function(i2, o3) {
      return A(n2, e2, t3, i2, o3, r2);
    }, true), t3;
  if (e2.A !== n2)
    return t3;
  if (!e2.P)
    return x(n2, e2.t, true), e2.t;
  if (!e2.I) {
    e2.I = true, e2.A._--;
    var o2 = e2.i === 4 || e2.i === 5 ? e2.o = l(e2.k) : e2.o;
    i(e2.i === 3 ? new Set(o2) : o2, function(t4, i2) {
      return A(n2, e2, o2, t4, i2, r2);
    }), x(n2, o2, false), r2 && n2.u && b("Patches").R(e2, r2, n2.u, n2.s);
  }
  return e2.o;
}
function A(e2, i2, o2, a2, c2, s2) {
  if (process.env.NODE_ENV !== "production" && c2 === o2 && n(5), t2(c2)) {
    var v2 = M(e2, c2, s2 && i2 && i2.i !== 3 && !u(i2.D, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, v2), !t2(v2))
      return;
    e2.m = false;
  }
  if (r(c2) && !y(c2)) {
    if (!e2.h.F && e2._ < 1)
      return;
    M(e2, c2), i2 && i2.A.l || x(e2, c2);
  }
}
function x(n2, t3, r2) {
  r2 === void 0 && (r2 = false), n2.h.F && n2.m && d(t3, r2);
}
function z(n2, t3) {
  var r2 = n2[Q];
  return (r2 ? p(r2) : n2)[t3];
}
function I(n2, t3) {
  if (t3 in n2)
    for (var r2 = Object.getPrototypeOf(n2); r2; ) {
      var e2 = Object.getOwnPropertyDescriptor(r2, t3);
      if (e2)
        return e2;
      r2 = Object.getPrototypeOf(r2);
    }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function R(n2, t3, r2) {
  var e2 = s(t3) ? b("MapSet").N(t3, r2) : v(t3) ? b("MapSet").T(t3, r2) : n2.g ? function(n3, t4) {
    var r3 = Array.isArray(n3), e3 = { i: r3 ? 1 : 0, A: t4 ? t4.A : _(), P: false, I: false, D: {}, l: t4, t: n3, k: null, o: null, j: null, C: false }, i2 = e3, o2 = en;
    r3 && (i2 = [e3], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e3.k = f2, e3.j = a2, f2;
  }(t3, r2) : b("ES5").J(t3, r2);
  return (r2 ? r2.A : _()).p.push(e2), e2;
}
function D(e2) {
  return t2(e2) || n(22, e2), function n2(t3) {
    if (!r(t3))
      return t3;
    var e3, u2 = t3[Q], c2 = o(t3);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
        return u2.t;
      u2.I = true, e3 = F(t3, c2), u2.I = false;
    } else
      e3 = F(t3, c2);
    return i(e3, function(t4, r2) {
      u2 && a(u2.t, t4) === r2 || f(e3, t4, n2(r2));
    }), c2 === 3 ? new Set(e3) : e3;
  }(e2);
}
function F(n2, t3) {
  switch (t3) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
var G;
var U;
var W = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol";
var X = typeof Map != "undefined";
var q = typeof Set != "undefined";
var B = typeof Proxy != "undefined" && Proxy.revocable !== void 0 && typeof Reflect != "undefined";
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var V = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n2) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n2) {
  return "Cannot apply patch, path doesn't resolve: " + n2;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n2) {
  return "Unsupported patch operation: " + n2;
}, 18: function(n2) {
  return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n2) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
}, 22: function(n2) {
  return "'current' expects a draft, got: " + n2;
}, 23: function(n2) {
  return "'original' expects a draft, got: " + n2;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames;
var tn = Object.getOwnPropertyDescriptors || function(n2) {
  var t3 = {};
  return nn(n2).forEach(function(r2) {
    t3[r2] = Object.getOwnPropertyDescriptor(n2, r2);
  }), t3;
};
var rn = {};
var en = { get: function(n2, t3) {
  if (t3 === Q)
    return n2;
  var e2 = p(n2);
  if (!u(e2, t3))
    return function(n3, t4, r2) {
      var e3, i3 = I(t4, r2);
      return i3 ? "value" in i3 ? i3.value : (e3 = i3.get) === null || e3 === void 0 ? void 0 : e3.call(n3.k) : void 0;
    }(n2, e2, t3);
  var i2 = e2[t3];
  return n2.I || !r(i2) ? i2 : i2 === z(n2.t, t3) ? (E(n2), n2.o[t3] = R(n2.A.h, i2, n2)) : i2;
}, has: function(n2, t3) {
  return t3 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, t3, r2) {
  var e2 = I(p(n2), t3);
  if (e2 == null ? void 0 : e2.set)
    return e2.set.call(n2.k, r2), true;
  if (!n2.P) {
    var i2 = z(p(n2), t3), o2 = i2 == null ? void 0 : i2[Q];
    if (o2 && o2.t === r2)
      return n2.o[t3] = r2, n2.D[t3] = false, true;
    if (c(r2, i2) && (r2 !== void 0 || u(n2.t, t3)))
      return true;
    E(n2), k(n2);
  }
  return n2.o[t3] === r2 && typeof r2 != "number" && (r2 !== void 0 || t3 in n2.o) || (n2.o[t3] = r2, n2.D[t3] = true, true);
}, deleteProperty: function(n2, t3) {
  return z(n2.t, t3) !== void 0 || t3 in n2.t ? (n2.D[t3] = false, E(n2), k(n2)) : delete n2.D[t3], n2.o && delete n2.o[t3], true;
}, getOwnPropertyDescriptor: function(n2, t3) {
  var r2 = p(n2), e2 = Reflect.getOwnPropertyDescriptor(r2, t3);
  return e2 ? { writable: true, configurable: n2.i !== 1 || t3 !== "length", enumerable: e2.enumerable, value: r2[t3] } : e2;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n2, t3) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], t3.apply(this, arguments);
  };
}), on.deleteProperty = function(t3, r2) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(r2)) && n(13), en.deleteProperty.call(this, t3[0], r2);
}, on.set = function(t3, r2, e2) {
  return process.env.NODE_ENV !== "production" && r2 !== "length" && isNaN(parseInt(r2)) && n(14), en.set.call(this, t3[0], r2, e2, t3[0]);
};
var un = function() {
  function e2(t3) {
    var e3 = this;
    this.g = B, this.F = true, this.produce = function(t4, i3, o2) {
      if (typeof t4 == "function" && typeof i3 != "function") {
        var u2 = i3;
        i3 = t4;
        var a2 = e3;
        return function(n2) {
          var t5 = this;
          n2 === void 0 && (n2 = u2);
          for (var r2 = arguments.length, e4 = Array(r2 > 1 ? r2 - 1 : 0), o3 = 1; o3 < r2; o3++)
            e4[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var r3;
            return (r3 = i3).call.apply(r3, [t5, n3].concat(e4));
          });
        };
      }
      var f2;
      if (typeof i3 != "function" && n(6), o2 !== void 0 && typeof o2 != "function" && n(7), r(t4)) {
        var c2 = w(e3), s2 = R(e3, t4, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? O(c2) : g(c2);
        }
        return typeof Promise != "undefined" && f2 instanceof Promise ? f2.then(function(n2) {
          return j(c2, o2), P(n2, c2);
        }, function(n2) {
          throw O(c2), n2;
        }) : (j(c2, o2), P(f2, c2));
      }
      if (!t4 || typeof t4 != "object") {
        if ((f2 = i3(t4)) === H)
          return;
        return f2 === void 0 && (f2 = t4), e3.F && d(f2, true), f2;
      }
      n(21, t4);
    }, this.produceWithPatches = function(n2, t4) {
      return typeof n2 == "function" ? function(t5) {
        for (var r3 = arguments.length, i4 = Array(r3 > 1 ? r3 - 1 : 0), o2 = 1; o2 < r3; o2++)
          i4[o2 - 1] = arguments[o2];
        return e3.produceWithPatches(t5, function(t6) {
          return n2.apply(void 0, [t6].concat(i4));
        });
      } : [e3.produce(n2, t4, function(n3, t5) {
        r2 = n3, i3 = t5;
      }), r2, i3];
      var r2, i3;
    }, typeof (t3 == null ? void 0 : t3.useProxies) == "boolean" && this.setUseProxies(t3.useProxies), typeof (t3 == null ? void 0 : t3.autoFreeze) == "boolean" && this.setAutoFreeze(t3.autoFreeze);
  }
  var i2 = e2.prototype;
  return i2.createDraft = function(e3) {
    r(e3) || n(8), t2(e3) && (e3 = D(e3));
    var i3 = w(this), o2 = R(this, e3, void 0);
    return o2[Q].C = true, g(i3), o2;
  }, i2.finishDraft = function(t3, r2) {
    var e3 = t3 && t3[Q];
    process.env.NODE_ENV !== "production" && (e3 && e3.C || n(9), e3.I && n(10));
    var i3 = e3.A;
    return j(i3, r2), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.F = n2;
  }, i2.setUseProxies = function(t3) {
    t3 && !B && n(20), this.g = t3;
  }, i2.applyPatches = function(n2, r2) {
    var e3;
    for (e3 = r2.length - 1; e3 >= 0; e3--) {
      var i3 = r2[e3];
      if (i3.path.length === 0 && i3.op === "replace") {
        n2 = i3.value;
        break;
      }
    }
    var o2 = b("Patches").$;
    return t2(n2) ? o2(n2, r2) : this.produce(n2, function(n3) {
      return o2(n3, r2.slice(e3 + 1));
    });
  }, e2;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);

// shared/src/globals.ts
var globals = {
  currentProjectStateDefinitionVersion: "0.4.0"
};
var globals_default = globals;

// core/src/projects/initialiseProjectState.ts
async function initialiseProjectState(studio, project, onDiskState) {
  await delay_default(0);
  studio.transaction(({ drafts }) => {
    var _a;
    const projectId = project.address.projectId;
    drafts.ephemeral.coreByProject[projectId] = {
      lastExportedObject: null,
      loadingState: { type: "loading" }
    };
    drafts.ahistoric.coreByProject[projectId] = {
      ahistoricStuff: ""
    };
    function useInitialState() {
      drafts.ephemeral.coreByProject[projectId].loadingState = {
        type: "loaded"
      };
      drafts.historic.coreByProject[projectId] = {
        sheetsById: {},
        definitionVersion: globals_default.currentProjectStateDefinitionVersion,
        revisionHistory: []
      };
    }
    function useOnDiskState(state) {
      drafts.ephemeral.coreByProject[projectId].loadingState = {
        type: "loaded"
      };
      drafts.historic.coreByProject[projectId] = state;
    }
    function useBrowserState() {
      drafts.ephemeral.coreByProject[projectId].loadingState = {
        type: "loaded"
      };
    }
    function browserStateIsNotBasedOnDiskState(onDiskState2) {
      drafts.ephemeral.coreByProject[projectId].loadingState = {
        type: "browserStateIsNotBasedOnDiskState",
        onDiskState: onDiskState2
      };
    }
    const browserState = (_a = e(drafts.historic)) == null ? void 0 : _a.coreByProject[project.address.projectId];
    if (!browserState) {
      if (!onDiskState) {
        useInitialState();
      } else {
        useOnDiskState(onDiskState);
      }
    } else {
      if (!onDiskState) {
        useBrowserState();
      } else {
        if (browserState.revisionHistory.indexOf(onDiskState.revisionHistory[0]) == -1) {
          browserStateIsNotBasedOnDiskState(onDiskState);
        } else {
          useBrowserState();
        }
      }
    }
  });
}

// core/src/projects/Project.ts
var Project = class {
  constructor(id, config = {}, publicApi) {
    this.config = config;
    this.publicApi = publicApi;
    __publicField(this, "pointers");
    __publicField(this, "_pointerProxies");
    __publicField(this, "address");
    __publicField(this, "_readyDeferred");
    __publicField(this, "_sheetTemplates", new import_dataverse15.Atom({}));
    __publicField(this, "sheetTemplatesP", this._sheetTemplates.pointer);
    __publicField(this, "_studio");
    __publicField(this, "type", "Theatre_Project");
    var _a;
    this.address = { projectId: id };
    const onDiskStateAtom = new import_dataverse15.Atom({
      ahistoric: {
        ahistoricStuff: ""
      },
      historic: (_a = config.state) != null ? _a : {
        sheetsById: {},
        definitionVersion: globals_default.currentProjectStateDefinitionVersion,
        revisionHistory: []
      },
      ephemeral: {
        loadingState: {
          type: "loaded"
        },
        lastExportedObject: null
      }
    });
    this._pointerProxies = {
      historic: new import_dataverse14.PointerProxy(onDiskStateAtom.pointer.historic),
      ahistoric: new import_dataverse14.PointerProxy(onDiskStateAtom.pointer.ahistoric),
      ephemeral: new import_dataverse14.PointerProxy(onDiskStateAtom.pointer.ephemeral)
    };
    this.pointers = {
      historic: this._pointerProxies.historic.pointer,
      ahistoric: this._pointerProxies.ahistoric.pointer,
      ephemeral: this._pointerProxies.ephemeral.pointer
    };
    projectsSingleton_default.add(id, this);
    this._readyDeferred = defer();
    if (config.state) {
      setTimeout(() => {
        if (!this._studio) {
          this._readyDeferred.resolve(void 0);
        }
      }, 0);
    } else {
      setTimeout(() => {
        if (!this._studio) {
          throw new Error(`Argument config.state in Theatre.getProject("${id}", config) is empty. This is fine while you are using @theatre/core along with @theatre/sutdio. But since @theatre/studio is not loaded, the state of project "${id}" will be empty.

To fix this, you need to add @theatre/studio into the bundle and export the projet's state. Learn how to do that at https://docs.theatrejs.com/in-depth/#exporting`);
        }
      }, 1e3);
    }
  }
  attachToStudio(studio) {
    if (this._studio) {
      if (this._studio !== studio) {
        throw new Error(`Project ${this.address.projectId} is already attached to studio ${this._studio.address.studioId}`);
      } else {
        console.warn(`Project ${this.address.projectId} is already attached to studio ${this._studio.address.studioId}`);
        return;
      }
    }
    this._studio = studio;
    studio.initialized.then(async () => {
      await initialiseProjectState(studio, this, this.config.state);
      this._pointerProxies.historic.setPointer(studio.atomP.historic.coreByProject[this.address.projectId]);
      this._pointerProxies.ahistoric.setPointer(studio.atomP.ahistoric.coreByProject[this.address.projectId]);
      this._pointerProxies.ephemeral.setPointer(studio.atomP.ephemeral.coreByProject[this.address.projectId]);
      this._readyDeferred.resolve(void 0);
    });
  }
  get isAttachedToStudio() {
    return !!this._studio;
  }
  get ready() {
    return this._readyDeferred.promise;
  }
  isReady() {
    return this._readyDeferred.status === "resolved";
  }
  getOrCreateSheet(sheetId, instanceId = "default") {
    let template = this._sheetTemplates.getState()[sheetId];
    if (!template) {
      template = new SheetTemplate(this, sheetId);
      this._sheetTemplates.setIn([sheetId], template);
    }
    return template.getInstance(instanceId);
  }
};

// shared/src/utils/sanitizers.ts
var _validateSym = (val7, thingy, range) => {
  if (typeof val7 !== "string") {
    return `${thingy} must be a string. ${userReadableTypeOfValue_default(val7)} given.`;
  } else if (val7.trim().length !== val7.length) {
    return `${thingy} must not have leading or trailing spaces. '${val7}' given.`;
  } else if (val7.length < range[0] || val7.length > range[1]) {
    return `${thingy} must have between ${range[0]} and ${range[1]} characters. '${val7}' given.`;
  }
};
var validateName = (name, thingy, shouldThrow = false) => {
  const result = _validateSym(name, thingy, [3, 32]);
  if (typeof result === "string" && shouldThrow) {
    throw new InvalidArgumentError(result);
  } else {
    return result;
  }
};
var validateInstanceId = (name, thingy, shouldThrow = false) => {
  const result = _validateSym(name, thingy, [1, 32]);
  if (typeof result === "string" && shouldThrow) {
    throw new InvalidArgumentError(result);
  } else {
    return result;
  }
};

// core/src/projects/TheatreProject.ts
var TheatreProject = class {
  get type() {
    return "Theatre_Project_PublicAPI";
  }
  constructor(id, config = {}) {
    setPrivateAPI(this, new Project(id, config, this));
  }
  get ready() {
    return privateAPI(this).ready;
  }
  get isReady() {
    return privateAPI(this).isReady();
  }
  get address() {
    return __spreadValues({}, privateAPI(this).address);
  }
  sheet(sheetId, instanceId = "default") {
    const sanitizedPath = validateAndSanitiseSlashedPathOrThrow(sheetId, "project.sheet");
    if (process.env.NODE_ENV !== "production") {
      validateInstanceId(instanceId, "instanceId in project.sheet(sheetId, instanceId)", true);
    }
    return privateAPI(this).getOrCreateSheet(sanitizedPath, instanceId).publicApi;
  }
};

// core/src/coreExports.ts
var import_fast_deep_equal2 = __toModule(require_fast_deep_equal());
var import_dataverse16 = __toModule(require("@theatre/dataverse"));
var import_dataverse17 = __toModule(require("@theatre/dataverse"));
function getProject(id, config = {}) {
  const restOfConfig = __objRest(config, []);
  const existingProject = projectsSingleton_default.get(id);
  if (existingProject) {
    if (process.env.NODE_ENV !== "production") {
      if (!(0, import_fast_deep_equal2.default)(config, existingProject.config)) {
        throw new Error(`You seem to have called Theatre.getProject("${id}", config) twice, with different config objects. This is disallowed because changing the config of a project on the fly can lead to hard-to-debug issues.

You can fix this by either calling Theatre.getProject() once per projectId, or calling it multiple times but with the exact same config.`);
      }
    }
    return existingProject.publicApi;
  }
  if (process.env.NODE_ENV !== "production") {
    validateName(id, "projectName in Theatre.getProject(projectName)", true);
    validateProjectIdOrThrow(id);
  }
  if (config.state) {
    if (process.env.NODE_ENV !== "production") {
      shallowValidateOnDiskState(id, config.state);
    } else {
      deepValidateOnDiskState(id, config.state);
    }
  }
  return new TheatreProject(id, restOfConfig);
}
var shallowValidateOnDiskState = (projectId, s2) => {
  if (Array.isArray(s2) || s2 == null || s2.definitionVersion !== globals_default.currentProjectStateDefinitionVersion) {
    throw new InvalidArgumentError(`Error validating conf.state in Theatre.getProject(${JSON.stringify(projectId)}, conf). The state seems to be formatted in a way that is unreadable to Theatre.js. Read more at https://docs.theatrejs.com`);
  }
};
var deepValidateOnDiskState = (projectId, s2) => {
  shallowValidateOnDiskState(projectId, s2);
};
var validateProjectIdOrThrow = (value) => {
  if (typeof value !== "string") {
    throw new InvalidArgumentError(`Argument 'projectId' in \`Theatre.getProject(projectId, ...)\` must be a string. Instead, it was ${userReadableTypeOfValue_default(value)}.`);
  }
  const idTrimmed = value.trim();
  if (idTrimmed.length !== value.length) {
    throw new InvalidArgumentError(`Argument 'projectId' in \`Theatre.getProject("${value}", ...)\` should not have surrounding whitespace.`);
  }
  if (idTrimmed.length < 3) {
    throw new InvalidArgumentError(`Argument 'projectId' in \`Theatre.getProject("${value}", ...)\` should be at least 3 characters long.`);
  }
};
function onChange(pointer3, callback) {
  if ((0, import_dataverse16.isPointer)(pointer3)) {
    const derivation = (0, import_dataverse17.valueDerivation)(pointer3);
    return derivation.tapImmediate(coreTicker_default, callback);
  } else if ((0, import_dataverse17.isDerivation)(pointer3)) {
    return pointer3.tapImmediate(coreTicker_default, callback);
  } else {
    throw new Error(`Called onChange(p) where p is neither a pointer nor a derivation.`);
  }
}
function val6(pointer3) {
  if ((0, import_dataverse16.isPointer)(pointer3)) {
    return (0, import_dataverse17.valueDerivation)(pointer3).getValue();
  } else {
    throw new Error(`Called val(p) where p is not a pointer.`);
  }
}

// shared/src/globalVariableNames.ts
var studioBundle = "__TheatreJS_StudioBundle";
var coreBundle = "__TheatreJS_CoreBundle";

// core/src/CoreBundle.ts
var CoreBundle = class {
  constructor() {
    __publicField(this, "_studio");
  }
  get type() {
    return "Theatre_CoreBundle";
  }
  get version() {
    return "0.4.7";
  }
  getBitsForStudio(studio, callback) {
    if (this._studio) {
      throw new Error(`@theatre/core is already attached to @theatre/studio`);
    }
    this._studio = studio;
    const bits = {
      projectsP: projectsSingleton_default.atom.pointer.projects,
      privateAPI,
      coreExports: coreExports_exports
    };
    callback(bits);
  }
};

// core/src/index.ts
registerCoreBundle();
function registerCoreBundle() {
  if (typeof window == "undefined")
    return;
  const existingBundle = window[coreBundle];
  if (typeof existingBundle !== "undefined") {
    if (typeof existingBundle === "object" && existingBundle && typeof existingBundle.version === "string") {
      throw new Error(`It seems that the module '@theatre/core' is loaded more than once. This could have two possible causes:
1. You might have two separate versions of theatre in node_modules.
2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.

Note that it **is okay** to import '@theatre/core' multiple times. But those imports should point to the same module.`);
    } else {
      throw new Error(`The variable window.${coreBundle} seems to be already set by a module other than @theatre/core.`);
    }
  }
  const coreBundle2 = new CoreBundle();
  window[coreBundle] = coreBundle2;
  const possibleExistingStudioBundle = window[studioBundle];
  if (possibleExistingStudioBundle && possibleExistingStudioBundle !== null && possibleExistingStudioBundle.type === "Theatre_StudioBundle") {
    possibleExistingStudioBundle.registerCoreBundle(coreBundle2);
  }
}
/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
//# sourceMappingURL=index.js.map
